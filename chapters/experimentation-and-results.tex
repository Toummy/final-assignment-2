\chapter{\label{chap:experimentation-and-results}Experimentação e Resultados Obtidos}

\todoin[caption={Detalhes}]{Introdução desse capítulo}

\section{\label{section:modifications}Modificações Realizadas}

\subsection{\textit{Scripts} de Compilação}

A escolha da linguagem \textit{C++} para a criação dos \textit{bots} requer que
o código seja compilado e que uma \textit{DLL} seja gerada, para que,
posteriormente, seja usada pelo \textit{SpelunkBots}. Este processo é feito em
várias etapas.  Primeiro, compilamos as bibliotecas que utilizamos. Em seguida,
compilamos o código dos \textit{bots} e geramos a \textit{DLL}. Por fim,
movemos a \textit{DLL} para o local onde o \textit{SpelunkBots} será executado.

É necessário executar com sucesso todas as etapas de compilação para viabilizar
o desenvolvvimento dos \textit{bots}. De forma a automatizar esse processo,
criamos um \textit{script} -- utilizando \textit{shell script} -- responsável
pelo processo de compilação e movimentação de arquivos.

\subsection{Pular Cena Inicial do Jogo}

Originalmente, o \textit{SpelunkBots} conta com uma cena inicial, onde o
jogador se desloca da superfície para dentro de uma caverna, dando início ao
jogo. Essa cena é apenas uma forma de introdução ao jogo, não contribuíndo para
a geração de resultados de execução.

De forma a acelerar a execução dos \textit{bots}, fizemos a remoção dessa cena
inicial. Portanto, ao executar o jogo, o jogador é levado diretamente ao nível
escolhido, fazendo sua execução imediatamante.

\subsection{Parar a Execução Quando o \textit{Bot} Está Ocioso}

Caso algum \textit{bot} fique parado por muito tempo, ou fique explorando uma
mesma posição muitas vezes, temos um indício de que ele esteja em um estado não
promissor, gastando tempo de execução. Logo, é necessário que tenhamos uma
forma de parar a execução do \textit{bot} nesses casos.

Com isso, implementamos uma verificação de ociosidade. A cada ciclo de execução
do jogo, verificamos se o \textit{bot} está parado, incrementando um contador
de tempo caso esteja. Zeramos esse contador caso ele se movimente. Após,
incrementamos o contador que indica o número de vezes que o \textit{bot}
visitou a posição em que está. Caso ele esteja parado por um determinado número
de segundos ou tenha visitado o mesmo estado por um determinado número de
vezes, sabemos que esse é um estado não promissor. Então, zeramos o número de
pontos de vida dele, fazendo com que o \textit{bot} perca uma vida e passe a
executar novamente.

\subsection{Arquivo de Inicialização}

O processo de escolha das configurações para a execução do jogo requer
experimentação. É necessário combinar diferentes parâmetros e avaliar sua
execução, escolhendo então os parâmetros que produzem os melhores resultados.
No caso do \textit{SpelunkBots}, essa escolha está ligada diretamente à edição
do código do jogo no \textit{Game Maker}. Sempre que desejamos editar um
parâmetro de execução, abrimos o \textit{software}, realizamos a edição dos
valores, salvamos uma nova versão do jogo e então o executamos. Esse processo é
manual e custoso, dificultando a escolha dos melhores parâmetros para execução.  

Dessa forma, alteramos o código do \textit{SpelunkBots} para permitir a leitura
de um arquivo de
inicialização\footnote{https://docs.yoyogames.com/source/dadiospice/002\_reference/file\%20handling/ini\%20files/index.html},
fazendo com que o jogo utilize valores dinâmicos para os parâmetros, sendo
possível então testar novas configurações e alterar a execução do jogo sem
a necessidade de abrirmos o \textit{Game Maker}. Tal arquivo tem um formato
bastante simples, onde cada elemento tem um nome que o identifica e um
valor associado, podendo estar em uma categoria.

O algoritmo ~\ref{alg:ini-file} apresenta esse arquivo de inicialização. Foram
utilizadas quatro categorias de valores. \textit{\textbf{[Bot]}} representa as
informações sobre o \textit{bot} escolhido na execução. A entrada
\textit{bot\_is\_cpp}, quando com o valor \textbf{1}, indica que se trata de um
\textit{bot} que foi escrito em \textit{C++}, já a entrada
\textit{bot\_cpp\_num} idica qual \textit{bot} será executado.  A categoria
\textit{\textbf{[Test]}} informa dados relativos ao teste que será realizado. O
tipo de mapa é informado pela entrada \textit{test\_type}. O parâmetro
\textit{test\_rank} indica ao \textit{SpelunkBots} como classificar a execução
dos \textit{bots}. Podemos controlar o número \textbf{máximo} de execuções pelo
valor de \textit{test\_num}. Também é possível limitar o tempo de vida de um
\textit{bot} pelo parâmetro \textit{test\_time}, que é indicado em segundos.
Podemos especificar os níveis que serão utilizados pelas entradas da categoria
\textit{\textbf{[Levels]}}. Primeiro, indicamos a quantidade de níveis pelo
valor de \textit{level\_num}. Após, para cada nível, indicamos o seu nome em
uma propriedade específica. No caso do primeiro, usamos a propriedade
\textit{level0}, para o segundo, \textit{level1}, e assim para todos eles.  Por
fim, temos a categoria \textit{\textbf{[FAMW]}}, que parametriza a exibição de
informações de depuração durante a execução do jogo.  O valor de
\textit{vision\_debug} indica se deverá ser exibida na tela uma janela da visão
do \textit{bot}, com o tamanho informado por \textit{vision\_size}.

\begin{algorithm}[H]
\lstinputlisting[style=customC++]{code/spelunkbots.ini}
\caption[Arquivo de inicialização de exemplo.]
{\label{alg:ini-file}Arquivo de inicialização de exemplo.}
\end{algorithm}

\subsection{Execução Sem Interface Gráfica}

O servidor \textit{Linux} que utilizamos para a execução não possui nenhuma
interface gráfica, além disso, não existe uma forma de executar o
\textit{Spelunky} ou o \textit{SpelunkBots} sem considerar uso de uma.

Porém, é possível fazer a criação de um \textit{display} virtual, onde
simulamos uma interface gráfica semelhante a uma real. Nesse caso, fizemos o
uso do
\textit{XVFB}\footnote{https://www.x.org/archive/X11R7.6/doc/man/man1/Xvfb.1.xhtml},
criando então uma interface gráfica que recebe a execução do jogo. O uso de uma
interface gráfica virtual também nos permite que gravemos vídeos do jogo, além
de permitir a captura de imagens da tela, permitindo que depuremos a execução
do jogo.

\section{\label{section:neat-details}Implementação do NEAT}

\todoin[caption={Implementação do NEAT}] {
    Explicar itens como:

    \begin{itemize}
		\item Lib utilizada
        \item Rede neural inicial
            \item Ferramenta para geração da rede inicial
        \item Parâmetros do NEAT
    \end{itemize}
}

\section{\label{section:results}Resultados}

\todoin[caption={Como apresentar os resultados?}, color=cyan!60] {
    Temos que pensar melhor como apresentar os resultados nessa seção.

    Temos que cobrir as seguintes coisas:

    \begin{itemize}
        \item Especificar o \textit{setup} utilizado (config Digital Ocean)
        \item Fitness
        \begin{itemize}
            \item Teste de fitness DT (winners e fitness) no mapa fácil,
                descobrindo que ela não é adequada no nosso caso, sendo
                descartada nas futuras comparações.
            \item Teste das fitness AM, WAM e HM no mapa fácil, comparando
                winners e fitness.
            \item Teste das fitness AM, WAM e HM no mapa médio, descobrindo que
                nenhuma é 100\% adequada.
            \item Teste da nova fitness que permite exploração.
            \item Teste da nova fitness que permite exploração com mais
                parâmetros de mutação.
        \end{itemize}
        \item Mutações
        \item Colocar os gráficos em um apêndice ou inline?
    \end{itemize}
}

\todoin[caption={Resultados}] {
    \begin{itemize}
        \item Configurações utilizadas
        \item Fitness por geração
        \item Tempo de execução
        \item Gráficos
        \item Imagem de uma rede neural dos resultados obtidos
    \end{itemize}
}
