\chapter{\label{chap:theory}Fundamentação Teórica}
Neste capítulo, apresentaremos a base teórica necessária para compreender o
funcionamento das técnicas de inteligência artificial escolhidas para realizar o
desenvolvimento dos agentes inteligentes de \textit{Spelunky}.


%----------
\section{\label{section:environment}Ambientes}
Todas as percepções e ações executadas por agentes racionais ocorrem no
\textbf{ambiente} no qual ele está inserido. A quantidade e variedade de
ambientes encontrados é vasta, mas é possível identificar dimensões (ou
características) de classificação para realizar uma categorização destes
ambientes. Estas características irão determinar que tipos de agentes --
enumerados na seção \ref{section:agents} -- são apropriados para cada ambiente.
As dimensões utilizadas para categorizar ambientes são:

\begin{description}
	\item[Observável, Parcialmente Observável ou Não-Observável]
		Um ambiente é observável se os sensores do agente lhe permitirem acesso
		completo ao estado do ambiente a cada ponto no tempo, o que torna este
		tipo de ambiente muito conveniente. O ambiente é parcialmente observável
		se os sensores do agente possuirem ruído ou não tiverem acesso completo
		ao ambiente. Se o agente não possuir nenhum tipo de sensor, então o
		ambiente é não-observável.

	\item[Agente Único ou Multi-Agente]
		Quando o agente não precisa interagir com nenhum outro agente no
		ambiente, então trata-se de um ambiente com agente único. Caso ele
		precise interagir de alguma forma (competição, cooperação ou
		comunicação) com outros agentes, então o ambiente é multi-agente.

	\item[Determinístico ou Estocástico]
		Um ambiente é determinístico caso não exista incerteza sobre o estado
		resultante da execução de uma ação em um determinado estado. Se houver
		qualquer grau de incerteza, o ambiente é estocástico.

	\item[Episódico ou Sequencial]
		Em ambientes episódicos, a experiência do agente é dividida em episódios
		atômicos, ou seja, são independentes entre sí. O agente não precisa
		pensar adiante pois, a cada episódio, recebe informações sensoriais e
		executa apenas uma ação, e o próximo episódio não será influenciado pela
		ação anterior. Já em ambientes sequenciais, a ação atual pode
		influenciar todas as decisões futuras, ou seja, ações a curto prazo
		podem ter consequências a longo prazo.

	\item[Discreto ou Contínuo]
		Ambientes discretos são aqueles onde se tem um número contável de ações
		e percepções possíveis. Em ambientes contínuos, o número de ações e de
		percepções muitas vezes são baseados em valores contínuos ou não são
		contáveis.

	\item[Conhecido ou Desconhecido]
		Esta distinção não se refere ao ambiente em sí, e sim sobre o
		conhecimento do agente (ou criador do agente) das "leis" de
		comportamento do ambiente. Em um ambiente conhecido, os resultados (ou
		probabilidades de resultados) das ações são conhecidos. Quando o
		ambiente é desconhecido, o agente precisa primeiro aprender como o
		ambiente funciona para saber fazer escolhas boas para atingir seus
		objetivos.
\end{description}


%----------
\section{\label{section:agents}Agentes Racionais}
Um agente é uma entidade que utiliza seus \textbf{sensores} para perceber o
ambiente no qual está inserido e interage através de seus \textbf{atuadores},
direcionando seus esforços para alcançar algum objetivo que se propõe a atingir
\cite[cap. 2]{RussellNorvig200912}. Um exemplo de agente racional é o ser
humano, que percebe o ambiente através de seus sentidos (visão, audição, entre
outros) e executa ações com seu corpo (braços, pernas, etc.). De acordo com
Russell \& Norvig \cite{RussellNorvig200912}, agentes racionais são agrupados
nas seguintes categorias: \textbf{agentes reflexivos}, \textbf{agentes baseados
em modelo}, \textbf{agentes baseados em objetivos} e \textbf{agentes baseados em
utilidade}.

Os \textbf{agentes reflexivos} são programados para executar ações baseadas em
algum evento percebido. Fica evidente que este tipo de agente simplesmente
executa uma ação baseado em suas percepções imediatas e não guardam informações
sobre suas experiências passadas, sendo apenas reativos.

Diferentemente dos agentes reflexivos, \textbf{agentes baseados em modelo} são
capazes de guardar informações sobre suas experiências passadas e sobre seu
estado atual. Este tipo de agente compreende como suas ações modificam o
ambiente onde está inserido e como o ambiente se altera independentemente de
suas ações, efetivamente construíndo um \textbf{modelo} do ambiente. 

As vezes, ter conhecimento sobre o estado atual do ambiente não é suficiente
para decidir que ação executar. O agente precisa de alguma informação de que
situações são desejáveis, ou que objetivos desejar cumprir. Este é o caso de
\textbf{agentes baseados em objetivo}, que combinam um modelo do ambiente com
informações de objetivo para escolher as ações que mais o aproximam dos estados
desejáveis. A escolha de ações baseada em objetivos pode ser simples -- quando,
por exemplo, o objetivo é antigido com a execução de apenas uma ação -- ou
complexo -- quando, por exemplo, o agente deve considerar longas cadeias de
ações para atingir seus objetivos.

Em alguns casos, os objetivos não são suficientes para gerar comportamentos de
alta qualidade. Por exemplo, muitas vezes é possível atingir um objetivo através
de várias sequências de ações, mas algumas sequências são mais rápidas, mais
seguras, mais confiáveis ou mais baratas. Os \textbf{agentes baseados em
utilidade} fazem uso de uma função de utilidade para medir sua performance e,
assim, distinguir estados mais desejáveis e menos desejáveis. O agente, então, é
capaz de escolher as ações mais vantajosas para ele, aumentando sua performance.


%----------
\section{\label{section:machine-learning}Aprendizado de Máquina}
Quando queremos resolver um problema através de um programa de computador,
desenvolvemos um algoritmo que, dado uma entrada, executa uma sequência de
operações para fornecer uma resposta adequada para a tarefa em questão. Um
exemplo disso são os algoritmos para ordenação de números, onde a entrada é
um conjunto de números e a resposta é o conjunto ordenado. Para alguns
problemas, contudo, nem sempre é possível se chegar a um algoritmo que resolve
satisfatóriamente uma tarefa. Por exemplo, a tarefa de diferenciar
\textit{e-mails} de \textit{spam} e \textit{e-mails} legítimos é complexa, pois
os \textit{e-mails} de \textit{spam} estão mudando constantemente, e a
categorização de \textit{spam} pode variar de indivíduo para indivíduo. Assim,
criar manualmente um algoritmo para resolver esta tarefa pode ser extremamente
complexo ou até mesmo impraticável. A partir deste contexto, surgiu a área de
\textbf{aprendizado de máquina}, que estuda algoritmos que fornecem a programas
de computador a habilidade de aprender e se aperfeiçoarem, tornando-os capazes
de resolver tarefas sem serem explicitamente programados.

Existem três tipos principais de aprendizado de máquina \cite[cap.
18]{RussellNorvig200912}, que são diferenciados entre sí pela natureza dos dados
utilizados para aprender. Estas categorias são: \textbf{aprendizado
supervisionado}, \textbf{aprendizado não-supervisionado} e \textbf{aprendizado
por reforço}. No aprendizado supervisionado, é fornecido um conjunto de dados
com exemplos de entrada e resultados esperados para aquelas entradas. Assim, a
tarefa neste tipo de aprendizado consiste em aprender uma função que mapeia
entradas para saídas. No aprendizado não-supervisionado, o programa recebe um
conjunto de dados de entrada mas não recebe informações com o tipo de saída
esperado. O objetivo deste tipo de aprendizado geralmente é detectar padrões em
conjuntos de dados.  O último tipo de aprendizado, o aprendizado por reforço, é
diferente dos demais porque está diretamente ligado ao conceito de agentes
racionais.  Neste tipo de aprendizado, o agente interage com um ambiente
dinâmico e deve atingir algum objetivo. Quando o agente executa ações no
ambiente, é fornecido a ele algum tipo de retorno -- recompensas ou punições --,
para que ele possa aprender a agir da maneira correta a fim de atingir seus
objetivos.

Para agentes racionais, a capacidade de aprender fornece a oportunidade de se
tornar mais competente que o permitido pelo seu conhecimento inicial do problema
e do ambiente. Problemas como informação incompleta ou inexistente sobre o
ambiente são mais facilmente contornados, pois o agente será capaz de criar um
modelo de representação através do retorno obtido após a execução de ações.


%----------
\section{\label{section:neural-networks}Redes Neurais Artificiais}
Uma \textbf{rede neural artificial} é um modelo matemático que busca replicar
computacionalmente (através de aproximações de funções) as capacidades de
processamento de informações de sistemas nervosos biológicos \cite[Cap.
1]{Rojas:1996:NNS:235222}. É uma técnica de aprendizado de máquina que
recentemente vem recebendo uma atenção especial, mas que teve suas origens no
início da década de 40 \cite[Cap. 18]{RussellNorvig200912}. Esta seção apresenta
apenas um resumo geral de redes neurais artificiais, pois o assunto é muito
complexo e um entendimento superficial do funcionamento desta técnica é
suficiente para este trabalho.

Os elementos fundamentais das redes neurais artificiais são as unidades de
processamento chamadas \textbf{neurônios} (também conhecidas como
\textit{perceptrons}) -- ilustrado na Figura \ref{fig:neural-networks-neurons}
\cite[Cap. 3]{Rojas:1996:NNS:235222}.  Cada neurônio possui um ou mais
\textbf{canais de entrada}, uma \textbf{função de integração}, uma
\textbf{função de ativação} e um ou mais \textbf{canais de saída}. O
funcionamento de um neurônio se dá da seguinte maneira: primeiro, a unidade
recebe as informações que deverá processar através de seus canais de entrada.
Estes canais possuem um \textbf{peso} atrelado a eles, que informa à unidade o
quão importante é a informação advinda daquela conexão. A origem das informações
não é relevante para o neurônio, e podem vir de outros neurônios ou de outras
classes de unidades de processamento (como a entrada da rede, por exemplo).
Todas as informações que o neurônio recebe passam por sua função de integração
(que geralmente é uma função de adição), cujo propósito é reduzir o número de
informações para apenas uma.  Depois de integrar as informações, o neurônio
realiza um processamento interno através de sua função de ativação,
transformando as informações recebidas em outro tipo de informação. Esta função
de ativação deve ser escolhida pelo desenvolvedor da rede e geralmente é ou uma
função de limiar (resultado $0$ ou $1$) ou uma função de logística (resultados
em números reais, como a função \textit{Sigmóide}). Na última etapa, o neurônio
envia, através de seus canais de saída, a informação que acabou de processar. Os
canais de saída se ligam com outros neurônios ou com a saída da rede.

% AIMA: page 728, figure 18.19
\begin{figure}[H]
\centering
\begin{tikzpicture}
    \def\layersep{4cm}
    \def\textsep{1.5cm}

    \node (a0) at (0, 2) {$a_0$};
    \node (a1) at (0, 1) {$a_1$};
    \node (an) at (0, 0) {$a_n$};

    \node [xshift=-.3cm, minimum width=\textsep, text centered] at (\layersep, 1) (neuron1) {$\sum_{}^{e_j}$};
    \node [minimum width=\textsep, text centered] at (\layersep + \textsep, 1) (neuron2) {};
    \node [xshift=.3cm, minimum width=\textsep, text centered, font=\footnotesize] at (\layersep + \textsep * 2, 1) (neuron3) {$a_j$};

    \node [font=\footnotesize] at (\layersep + \textsep, 1.5) {g};

    \draw [thick]
        (\layersep + \textsep - .5cm, .5)
            ..
               controls (\layersep + \textsep + .8, .5) and
                        (\layersep + \textsep + .4, 1.5)
            ..
        (\layersep + \textsep + .5cm, 1.5)
    ;

    \node (s0) at (\layersep * 2 + \textsep * 2, 2) {$s_0$};
    \node (s1) at (\layersep * 2 + \textsep * 2, 1) {$s_1$};
    \node (sn) at (\layersep * 2 + \textsep * 2, 0) {$s_n$};

    \node (p0) at (1, 2) {$p_0$};
    \node (p1) at (1, 1.2) {$p_1$};
    \node (pn) at (1, .4) {$p_n$};

    \node (neuron) [shape=ellipse, draw, thick, inner xsep=-.5cm, inner ysep=.5cm, fit={(neuron1) (neuron2) (neuron3)}] {};

    \draw [thick] (neuron.130) -- (neuron.230);
    \draw [thick] (neuron.50) -- (neuron.310);

    \node [text width=\textsep, font=\scriptsize, text centered]
        at (.5, -1)
        {Canais de Entrada}
    ;
    \node [xshift=-.3cm, text width=\textsep, font=\scriptsize, text centered]
        at (\layersep, -1)
        {Função de Integração}
    ;

    \node [text width=\textsep, font=\scriptsize, text centered]
        at (\layersep + \textsep, -1)
        {Função de Ativação}
    ;

    \node [xshift=.3cm, text width=\textsep, font=\scriptsize, text centered]
        at (\layersep + \textsep * 2, -1)
        {Saída}
    ;

    \node [text width=\textsep, font=\scriptsize, text centered]
        at (\layersep * 2.5, -1)
        {Canais de Saída}
    ;

    \path[->,>=latex] (a0) edge (neuron);
    \path[->,>=latex] (a1) edge (neuron);
    \path[->,>=latex] (an) edge (neuron);

    \path[->,>=latex] (neuron) edge (s0);
    \path[->,>=latex] (neuron) edge (s1);
    \path[->,>=latex] (neuron) edge (sn);
\end{tikzpicture}
\caption {\label{fig:neural-networks-neuron}Ilustração que indica os principais
componentes de um neurônio de uma rede neural artificial.}
\end{figure}

Com as unidades de processamento definidas, o próximo passo é entender como elas
se conectam entre sí para formar a \textbf{topologia} da rede neural. Existem,
fundamentalmente, dois modelos básicos de topologia: sem realimentação
(\textit{feed-forward}) e recorrentes \cite[Cap. 18]{RussellNorvig200912}. As
redes sem realimentação, como o próprio nome sugere, possui conexões em somente
um sentido (para frente), ou seja, os neurônios processam as informações apenas
uma vez. Já nas redes recorrentes, um neurônio pode processar informações mais
de uma vez (realimentação de informações processadas anteriormentes pela rede).
Por fins de simplificação, a explicação desta seção se concentrará em redes sem
realimentação.

As redes neurais artificiais sem realimentação geralmente estão estruturadas em
\textbf{camadas}, sendo que os neurônios recebem entradas somente de unidades de
processamento da camada anterior. A topologia da rede é dividida,
essencialmente, em uma \textbf{camada de entrada}, zero ou mais \textbf{camadas
escondidas} e uma \textbf{camada de saída}. Quando a rede não possui camadas
escondidas, ela é chamada de \textbf{camada-única}, e quando possui camadas
escondidas é chamada de \textbf{multi-camada}. Quase sempre é necessário
adicionar camadas escondidas, pois a maioria das funções não podem ser
aproximadas corretamente com apenas uma camada (a função lógica \textit{XOR} é
um exemplo disso). Isto ocorre porque quando se tem apenas uma camada de
processamento, só é possível aproximar funções linearmente separáveis(detalhes
em \cite[Cap. 18]{RussellNorvig200912}). As unidades de processamento são
conectadas (geralmente, todos os neurônios de uma camada possuem conexão com
todos os neurônios da camada seguinte) e a rede neural se forma. Dependendo do
problema, a escolha de quantas camadas e unidades de processamento afeta a
qualidade dos resultados obtidos. Não existe uma ciência exata para definir
quantidades de camadas e neurônios, ficando a critério do desenvolvedor a
análise do problema e a experimentação de topologias \cite[Cap.
18]{RussellNorvig200912}. A Figura \ref{fig:neural-networks-example} ilustra uma
possível topologia de uma rede neural artificial sem realimentação.

% Neural Networks: A Systematic Introduction, page 126, figure 6.1
\begin{figure}[H]
\centering
\begin{tikzpicture}[shorten >=1pt,->,draw=black!50, node distance=\layersep]
    \def\layersep{4cm}
    \tikzstyle{every node}=[font=\footnotesize]
    \tikzstyle{every pin edge}=[<-,shorten <=1pt]
    \tikzstyle{neuron}=[circle,fill=black!25,minimum size=17pt,inner sep=0pt]
    \tikzstyle{input neuron}=[neuron, fill=gray!50];
    \tikzstyle{output neuron}=[neuron, fill=gray!50];
    \tikzstyle{hidden neuron}=[neuron, fill=gray!50];
    \tikzstyle{annot} = [text width=10em, text centered]

    % Draw the input layer nodes
    \foreach \name / \y in {1,...,4}
    % This is the same as writing \foreach \name / \y in {1/1,2/2,3/3,4/4}
        \node[input neuron, pin=left:Entrada \#\y] (I-\name) at (0,-\y) {};

    % Draw the hidden layer nodes
    \foreach \name / \y in {1,...,5}
        \path[yshift=0.5cm]
            node[hidden neuron] (H-\name) at (\layersep,-\y cm) {};

    % Draw the output layer node
    \node[output neuron,pin={[pin edge={->}]right:Saída}, right of=H-3] (O) {};

    % Connect every node in the input layer with every node in the
    % hidden layer.
    \foreach \source in {1,...,4}
        \foreach \dest in {1,...,5}
            \path (I-\source) edge (H-\dest);

    % Connect every node in the hidden layer with the output layer
    \foreach \source in {1,...,5}
        \path (H-\source) edge (O);

    % Annotate the layers
    \node[annot,above of=H-1, node distance=1cm] (hl) {Camada Intermediária (Escondida)};
    \node[annot,left of=hl] {Camada de Entrada};
    \node[annot,right of=hl] {Camada de Saída};
\end{tikzpicture}
\caption {\label{fig:neural-networks-example}Ilustração de uma possível topologia
de uma rede neural artificial sem realimentação.}
\end{figure}


O objetivo das redes neurais artificiais, então, é gerar uma \textbf{função de
rede}, que recebe informações na camada de entrada, realiza processamentos com
seus neurônios e envia informações através de um ou mais neurônios na camada de
saída. Esta função de rede deve ser uma aproximação (pois nem sempre atinge
100\% de precisão) da função que queremos descobrir. A rede neural deve passar,
portanto, por um processo de \textbf{treinamento}, que tentará ajustar os pesos
das conexões dos neurônios até encontrar valores adequados. Aqui, o tipo de
treinamento que a rede recebe depende do tipo de aprendizado que está sendo
empregado (supervisionado, não-supervisionado ou por reforço). Um exemplo de
algoritmo de treinamento é o da \textbf{retropropagação}
(\textit{backpropagation}), muito utilizado para treinar redes neurais
artificiais em aprendizado supervisionado. Este algoritmo tenta ajustar os pesos
das conexões através da análise e minimização do erro entre os resultados
esperados (dados de treinamento) e os resultados obtidos através do uso da
função aproximada da rede neural \cite[Cap. 7]{Rojas:1996:NNS:235222}.


%----------
% gene
% genotype
% genome
% phenotype
% individual
% population
% environment
% fitness
% reproduction
% offspring
% mutation
% generation
\section{\label{section:evolutionary-algorithms}Algoritmos Evolutivos}
A \textbf{computação evolutiva} é uma área da Ciência da Computação que, como o
nome sugere, se inspira na ciência da genética e no processo de evolução natural
descrito por Charles Darwin para construir algoritmos que solucionam problemas
computacionais \cite[Cap. 2]{IntroEvolComputing}. 

Todos os seres vivos, ou \textbf{indivíduos}, são uma entidade dupla formados
por um \textbf{fenótipo} e um \textbf{genótipo}. O fenótipo são as
características observáveis do indivíduo, como seu comportamento e seu aspecto
físico. Já o genótipo representa a constituição genética do indivíduo. O
fenótipo de um indivíduo é descrito por seus \textbf{genes}, unidades funcionais
de herança genética presentes descritas dentro de seu \textbf{genoma}
(informação genética completa de um indivíduo).

O processo biológico de evolução pode ser resumido da seguinte forma: os
indivíduos fazem parte de uma \textbf{população} e vivem dentro de um ambiente.
Como este ambiente possui recursos limitados, a competição por recursos é
natural, e a \textbf{aptidão} de um indivíduo afeta a sua probabilidade de
sobrevivência. Esta aptidão é determinada por seu fenótipo, ou seja, por suas
características físicas e pela maneira na qual interage com o ambiente e os
demais indivíduos. Desta forma, o processo de seleção natural tende a favorecer
indivíduos com boas características fenotípicas.  Quando um indivíduo entra em
processo de \textbf{reprodução} seja assexuadamente, seja sexuadamente, ele gera
\textbf{descendentes}. O genoma dos descendentes, contudo, não é o mesmo que o
de seus pais, pois pequenas variações reprodutivas e \textbf{mutações}
(variações) ocorrem durante a reprodução. Desta forma, variações genotípicas são
criadas, que são traduzidas para variações fenotípicas. 

Os \textbf{algoritmos evolutivos} se baseiam neste processo biológico para
resolver problemas computacionais. O esqueleto de um algoritmo evolutivo,
exemplificado no algoritmo \ref{alg:evolutionary-algorithm-skeleton}, geralmente
segue o seguinte padrão \cite[Cap. 3]{IntroEvolComputing}: dada uma função que
deseja ser maximizada (aptidão dos indivíduos), cria-se aleatóriamente uma
população inicial de invidíduos (candidatos). Em seguida, aplica-se
repetidamente uma \textbf{função de aptidão} para descobrir quais são os
melhores candidatos para procriar e dar origem a uma nova \textbf{geração}. Esta
nova geração de indivíduos é criada através de uma \textbf{recombinação} entre
os genomas seus pais e de uma \textbf{mutação} em seus genomas.  Este processo é
repetido diversas vezes, até que atinja um critério de parada pré-estabelecido,
como o surgimento de um indivíduo com um nível de aptidão aceitável ou um limite
máximo de iterações computacionais. É importante ressaltar que muitos
componentes deste processo evolutivo são \textbf{estocásticos}.  Geralmente (e
eventualmente), os indivíduos com baixa aptidão são escolhidos para serem
substituídos, mas não há total garantia disso, pois eles podem ser beneficiados
pela "sorte". Os processos de recombinação e mutação também escolhem os genes a
serem combinados e substituídos ao acaso.

\begin{algorithm}[h]
\begin{center}
	\begin{algorithmic}[1]
        \STATE POPULAÇÃO $\gets$ candidatos gerados aleatóriamente
		\STATE AVALIAR cada candidato
		\REPEAT
			\STATE{SELECIONAR pais adequados}
			\STATE{RECOMBINAR genomas dos pais}
			\STATE{MUTACIONAR os descendentes}
			\STATE{AVALIAR cada novo candidato}
			\STATE{SELECIONAR indivíduos para a próxima geração}
		\UNTIL{APTIDÃO mínima atingida \OR ITERAÇÕES esgotadas}
    \end{algorithmic}
\end{center}
\caption[Esquema geral, em pseudocódigo, de um algoritmo evolutivo.]
{\label{alg:evolutionary-algorithm-skeleton} Esquema geral, em pseudocódigo, de
um algoritmo evolutivo.}
\end{algorithm}

Para que se possa utilizar um algoritmo evolutivo a fim de resolver um problema
computacional, é necessário escolhar uma \textbf{representação genética} para o
problema \cite[Cap. 4]{IntroEvolComputing}. Este processo envolve a definição de
um genótipo e o mapeamento entre genótipo e fenótipo, e é fundamental pois
somente com a representação genética em mãos será possível executar os processos
evolutivos de recombinação e mutação. Existem diversas maneiras de representar o
código genético dos indivíduos, como a \textbf{representação binária}, a
\textbf{representação por inteiros}, a \textbf{representação em árvore}, entre
outras. O último passo, antes de iniciar o uso de qualquer algoritmo evolutivo,
é a escolha dos \textbf{parâmetros de execução} \cite[Cap.
7]{IntroEvolComputing}, que variam desde o tamanho da população até a chance de
realizar uma operação de mutação, por exemplo.


%----------
\section{\label{section:behavior-trees}Behavior Trees}
A construção de bons agentes inteligentes depende fortemente da capacidade que
os agentes têm de tomar boas decisões de comportamento. No contexto de jogos
digitais, a partir da década de 90, a qualidade da inteligência artificial
passou a ser um diferencial no momento de compra de um jogo\cite[Cap.
1]{Millington:2009:AIG:1795711}, aumentando a importância da escolha de uma
técnica apropriada para desenvolver os agentes inteligentes.Das técnicas mais
populares, a \textbf{\textit{Behavior Tree}}, ou Árvore de Comportamento, é uma
das técnicas que mais se destaca, devido a sua \textbf{simplicidade} e
\textbf{extensibilidade}\cite[Cap.  4]{Rabin:2013:GAP:2566761}, e já foi
utilizada na indústria em jogos como \textit{Halo 2}\cite[Cap.
5]{Millington:2009:AIG:1795711} e
\textit{Spore}\footnote{http://chrishecker.com/My\_liner\_notes\_for\_spore},
por exemplo.

Uma \textit{Behavior Tree} é uma estrutura de dados baseada em árvore que contém
um nodo \textbf{raíz} (geralmente utilizada para controlar o fluxo inicial de
execução) e vários nodos filhos que representam os \textbf{comportamentos}. Cada
comportamento deve possuir uma \textbf{pré-condição} e uma \textbf{ação}. Caso a
pré-condição seja satisfeita, o agente poderá executar o comportamento descrito
pela ação do nodo\cite[Cap. 4]{Rabin:2013:GAP:2566761}. Isto faz com que o
algoritmo de execução seja simples: partimos do nodo raíz em busca do primeiro
filho que satisfaça sua pré-condição (geralmente da esquerda para a direita). Ao
encontrá-lo, executamos sua ação. É importante ressaltar que somente um
comportamento é selecionado por vez. Portanto, se um comportamento for
selecionado, o algoritmo não tentará executar as ações dos nodos vizinhos na
mesma execução do algoritmo.

É possível adicionar estruturas de \textbf{controle de fluxo} a uma
\textit{Behavior Tree}. Desta forma, os ramos da árvore passam a ser usados para
controlar o fluxo de execução, enquanto os nodos-folha representam as
pré-condições e ações\cite[Cap. 10]{Rabin:2015:GAP:2821138}. Quando uma ação de
um nodo-folha é executado, ele informa ao seu pai (controlador de fluxo) o
estado de sua execução -- sucesso, falha ou em andamento. Existem diversos
tipos de estruturas de controle de fluxo que são utilizadas em \textit{Behavior
Trees}, mas as mais comuns são os de \textbf{seleção} e de \textbf{sequência}.

O algoritmo do controle de fluxo de seleção -- exemplificado no algoritmo
\ref{alg:behavior-tree-selection} -- faz a execução do \textbf{primeiro nodo
filho} que tiver sua pré-condição satisfeita. Quando termina de executar a ação
selecionada, aborta o procedimento, não visitando as demais ações.
Diferentemente do algoritmo de seleção, o algoritmo de \textbf{sequência} --
exemplificado no algoritmo \ref{alg:behavior-tree-sequence} -- tentará executar
\textbf{todos} os nodos que satisfizerem suas pré-condições de forma
\textbf{sequencial}. Sua execução só é interrompida quando não for possível
tomar a ação descrita pelo nodo ou quando não existirem mais nodos para se
avaliar.

\begin{algorithm}[H]
\begin{center}
	% Um exemplo de algoritmo utilizando a pacote 'algorithmic'
	%\algsetup{linenosize=\small,linenodelimiter=.}
	\begin{algorithmic}[1]
        \STATE filhos $\gets$ lista de nodos filhos
        \FOR{cada filho em filhos}
            \IF{filho.executar() == true}
                \RETURN true
            \ENDIF
        \ENDFOR
        \RETURN false
    \end{algorithmic}
\end{center}
\caption[Algoritmo para execução do controle de fluxo do tipo seleção em uma
behavior tree.]
{\label{alg:behavior-tree-selection} Algoritmo para execução do controle de
fluxo do tipo seleção em uma behavior tree.}
\end{algorithm}

\begin{algorithm}[H]
\begin{center}
	% Um exemplo de algoritmo utilizando a pacote 'algorithmic'
	%\algsetup{linenosize=\small,linenodelimiter=.}
	\begin{algorithmic}[1]
        \STATE filhos $\gets$ lista de nodos filhos
        \FOR{cada filho em filhos}
            \IF{filho.executar() == false}
                \RETURN false
            \ENDIF
        \ENDFOR
        \RETURN true
    \end{algorithmic}
\end{center}
\caption[Algoritmo para execução do controle de fluxo do tipo sequência em uma
behavior tree.]
{\label{alg:behavior-tree-sequence} Algoritmo para execução do controle de fluxo
do tipo sequência em uma behavior tree.}
\end{algorithm}

Para que fique mais claro como a técnica é utilizada, criamos um cenário
hipotético onde devemos criar a inteligência artificial de um agente (um robô
doméstico) que tem uma tarefa muito importante: limpar e organizar os móveis da
sala de estar de uma casa. Este robô, contudo, é movido à baterias, que não
duram muito. Então, de tempos em tempos, é necessário que ele recarregue suas
energias. Existem duas fontes de energia disponíveis para o robô: energia solar
e energia elétrica. A energia solar é preferível, por ser uma forma de energia
mais limpa, mas nem sempre é possível utilizá-la (um dia chuvoso, por exemplo).
Caso o robô termine suas tarefas e não esteja com níveis baixos de bateria, pode
descansar, entrando em modo de repouso.  A Figura
\ref{fig:behavior-tree-example} representa o comportamento deste agente através
de uma \textit{Behavior Tree}. Para decidir entre as fontes de energia, usamos
um controle de fluxo do tipo \textbf{seleção}, pois somente um tipo de energia
deve ser utilizado. Já para executar suas tarefas (limpar e organizar), usamos
um controle de fluxo do tipo \textbf{sequência}, pois todas as tarefas devem ser
executadas.

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    every node/.style={
        font=\scriptsize
    },
    composite/.style={
        minimum width=1.3cm, minimum height=1.2cm,
        text width=1.3cm,
        text centered,
        rounded rectangle,
        draw
    },
    action/.style={
        minimum width=1.3cm, minimum height=1.2cm,
        text width=1.3cm,
        text centered,
        rectangle,
        draw
    },
    precond/.style={
        minimum width=1.3cm, minimum height=1.2cm,
        text width=1.3cm,
        text centered,
        rectangle,
        fill=black,
        text=white
    }
]
\matrix [row sep=1cm, column sep=0.3cm] {
                                                &
                                                &
                                                &
    \node (n1)  [action]    {Raíz};             &
                                                &
                                                &
                                                &
                                                &
                                                &
    \\
                                                &
    \node (n2)  [composite] {Selecionar};       &
                                                &
                                                &
    \node (n4)  [composite] {Sequência};        &
                                                &
    \node (n3)  [action]    {Descansar};        &
                                                &
                                                &
    \\
    \node (n5)  [precond]   {Pouca Energia?};   &
    \node (n7)  [action]    {Energia Solar};    &
    \node (n6)  [action]    {Energia Elétrica}; &
    \node (n8)  [precond]   {Casa Suja?};       &
    \node (n9)  [action]    {Limpar Sala};      &
    \node (n10) [action]    {Organizar Móveis}; &
                                                &
                                                &
                                                &
    \\
};
\draw[->,>=latex] (n1.south) -- (n2.north);
\draw[->,>=latex] (n1.south) -- (n3.north);
\draw[->,>=latex] (n1.south) -- (n4.north);

\draw[->,>=latex] (n2.south) -- (n5.north);
\draw[->,>=latex] (n2.south) -- (n6.north);
\draw[->,>=latex] (n2.south) -- (n7.north);

\draw[->,>=latex] (n4.south) -- (n8.north);
\draw[->,>=latex] (n4.south) -- (n9.north);
\draw[->,>=latex] (n4.south) -- (n10.north);
\end{tikzpicture}
\caption {\label{fig:behavior-tree-example}Exemplo de uma \textit{behaviour
tree} para representar um agente que deve carregar suas baterias caso seja
necessário, além de limpar e organizar a casa, descansando caso contrário.}
\end{figure}

Existem algumas outras técnicas que resolvem o mesmo problema que as
\textit{Behavior Trees} como, por exemplo, as \textbf{\textit{Finite State
Machines}} (máquinas de estados finitos), que são muito utilizadas em
inteligência artificial para jogos. Uma \textit{FSM} contém \textbf{estados} que
são ligados através de \textbf{transições}. Contudo, existem diversos problemas
com esta abordagem. A quantidade de estados e transições cresce
exponencialmente, os estados não podem ser reutilizados com facilidade e devemos
nos preocupar constantemente se existem transições inválidas no modelo. As
\textit{FSMs} possuem, resumidamente, um problema de modularidade.

Outra técnica muito utilizada são as \textbf{\textit{Hierarchical Finite State
Machines}} (máquinas de estados finitos hierárquicas). O objetivo da criação
desta técnica foi justamente mitigar alguns dos problemas das \textit{FSMs},
permitindo o englobamento de estados em uma hierarquia. Entretanto, o problema
de extensibilidade e praticidade ainda existem, porque ainda é baseada em
transições.


%----------
\section{\label{section:neat}NEAT}
% NEAT
% neuroevolução
% NEAT evolui os pesos e a rede em sí (TWEANNs)
% representação genética da rede
% problemas comuns em TWEANNs que o NEAT resolve
% (competing conventions, protecting innovation e initial population)

\begin{mdframed}[backgroundcolor=green!20]
\begin{itemize}
    \item
        Introdução: Escolha da técnica, história, paper
    \item
        Relação com aprendizado de máquina
    \item
        Relação com algoritmos genéticos
    \item
        Relação com redes neurais
    \item
        Explicação sobre a técnica: detalhamento de como funciona, termos
        técnicos, exemplos, pedaços de código (se necessário)
    \item
        Como será utilizada na construção dos \textit{bots}
\end{itemize}
\end{mdframed}
