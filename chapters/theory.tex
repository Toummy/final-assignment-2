\chapter{\label{chap:theory}Fundamentação Teórica}
Neste capítulo, apresentaremos a base teórica necessária para compreender o
funcionamento das técnicas \textit{Behavior Trees} e \textit{NEAT}, escolhidas
para realizar o desenvolvimento dos agentes inteligentes de \textit{Spelunky}.

\begin{mdframed}[backgroundcolor=green!20]
\begin{itemize}
	\item
		TODO
\end{itemize}
\end{mdframed}


%----------
\section{\label{section:environment}Ambientes}
Todas as percepções e ações executadas por agentes racionais ocorrem no
\textbf{ambiente} no qual ele está inserido. A quantidade e variedade de
ambientes encontrados é vasta, mas é possível identificar dimensões (ou
características) de classificação para realizar uma categorização destes
ambientes. Estas características irão determinar que tipos de agentes --
enumerados na seção \ref{section:agents} -- são apropriados para cada ambiente.
As dimensões utilizadas para categorizar ambientes são:

\begin{description}
	\item[Observável, Parcialmente Observável ou Não-Observável]
		Um ambiente é observável se os sensores do agente lhe permitirem acesso
		completo ao estado do ambiente a cada ponto no tempo. Ambientes
		observáveis são convenientes, pois o agente não precisa manter um estado
		interno de conhecimento para se manter informado. O ambiente é
		parcialmente observável se os sensores do agente possuirem ruído ou não
		tiverem acesso completo ao ambiente. Se o agente não possuir nenhum tipo
		de sensor, então o ambiente é não-observável.

	\item[Agente Único ou Multi-Agente]
		Quando o agente não precisa interagir com nenhum outro agente no
		ambiente, então trata-se de um ambiente com agente único. Caso ele
		precise interagir de alguma forma (competição, cooperação ou
		comunicação) com outros agentes, então o ambiente é multi-agente.

	\item[Determinístico ou Estocástico]
		Se o próximo estado do ambiente for completamente determinado pela
		combinação do estado atual com uma ação executada pelo agente, então o
		ambiente é determinístico. Caso contrário, é estocástico.

	\item[Episódico ou Sequencial]
		Em ambientes episódicos, a experiência do agente é dividida em episódios
		atômicos, ou seja, são independentes entre sí. O agente não precisa
		pensar adiante pois, a cada episódio, recebe informações sensoriais e
		executa apenas uma ação, e o próximo episódio não será influenciado pela
		ação anterior. Já em ambientes sequenciais, a ação atual pode
		influenciar todas as decisões futuras, ou seja, ações a curto prazo
		podem ter consequências a longo prazo.

	\item[Discreto ou Contínuo]
		Ambientes discretos são aqueles onde se tem um número contável de ações
		e percepções possíveis. Em ambientes contínuos, o número de ações e de
		percepções muitas vezes são baseados em valores contínuos ou não são
		contáveis.

	\item[Conhecido ou Desconhecido]
		Esta distinção não se refere ao ambiente em sí, e sim sobre o
		conhecimento do agente (ou criador do agente) das "leis" de
		comportamento do ambiente. Em um ambiente conhecido, os resultados (ou
		probabilidades de resultados) das ações são conhecidos. Quando o
		ambiente é desconhecido, o agente precisa primeiro aprender como o
		ambiente funciona para saber fazer escolhas boas para atingir seus
		objetivos.
\end{description}


%----------
\section{\label{section:agents}Agentes Racionais}
Um agente é uma entidade que utiliza seus \textbf{sensores} para perceber o
ambiente no qual está inserido e interage através de seus \textbf{atuadores},
direcionando seus esforços para alcançar algum objetivo que se propõe a
atingir\cite[cap. 2]{RussellNorvig200912}. Um exemplo de agente racional é o ser
humano, que percebe o ambiente através de seus sentidos (visão, audição, entre
outros) e executa ações com seu corpo (braços, pernas, etc.). De acordo com
Russell \& Norvig\cite{RussellNorvig200912}, agentes racionais são agrupados nas
seguintes categorias: \textbf{agentes reflexivos}, \textbf{agentes baseados em
modelo}, \textbf{agentes baseados em objetivos} e \textbf{agentes baseados em
utilidade}.

Os \textbf{agentes reflexivos} são programados para executar ações baseadas em
algum evento percebido. Fica evidente que este tipo de agente simplesmente
executa uma ação baseado em suas percepções imediatas e não guardam informações
sobre suas experiências passadas, sendo apenas reativos.

Diferentemente dos agentes reflexivos, \textbf{agentes baseados em modelo} são
capazes de guardar informações sobre suas experiências passadas e sobre seu
estado atual. Este tipo de agente compreende como suas ações modificam o
ambiente onde está inserido e como o ambiente se altera independentemente de
suas ações, efetivamente construíndo um \textbf{modelo} do ambiente. 

Às vezes, ter conhecimento sobre o estado atual do ambiente não é suficiente
para decidir que ação executar. O agente precisa de alguma informação de que
situações são desejáveis, ou que objetivos desejar cumprir. Este é o caso de
\textbf{agentes baseados em objetivo}, que combinam um modelo do ambiente com
informações de objetivo para escolher as ações que mais o aproximam dos estados
desejáveis. A escolha de ações baseada em objetivos pode ser simples -- quando,
por exemplo, o objetivo é antigido com a execução de apenas uma ação -- ou
complexo -- quando, por exemplo, o agente deve considerar longas cadeias de
ações para atingir seus objetivos.

Em alguns casos, os objetivos não são suficientes para gerar comportamentos de
alta qualidade. Por exemplo, muitas vezes é possível atingir um objetivo através
de várias sequências de ações, mas algumas sequências são mais rápidas, mais
seguras, mais confiáveis ou mais baratas. Os \textbf{agentes baseados em
utilidade} fazem uso de uma função de utilidade para medir sua performance e,
assim, distinguir estados mais desejáveis e menos desejáveis. O agente, então, é
capaz de escolher as ações mais vantajosas para ele, aumentando sua performance.


%----------
\section{\label{section:machine-learning}Aprendizado de Máquina}
Quando queremos resolver um problema através de um programa de computador,
desenvolvemos um algoritmo que, dado uma entrada, executa uma sequência de
operações para fornecer uma resposta adequada para a tarefa em questão. Um
exemplo disso seriam os algoritmos para ordenação de números, onde a entrada é
um conjunto de números e a resposta é o conjunto ordenado. Para alguns
problemas, contudo, nem sempre é possível se chegar a um algoritmo que resolve
satisfatóriamente uma tarefa. Por exemplo, a tarefa de diferenciar
\textit{e-mails} de \textit{spam} e \textit{e-mails} legítimos é complexa, pois
os \textit{e-mails} de \textit{spam} estão mudando constantemente, e a
categorização de \textit{spam} pode variar de indivíduo para indivíduo. Assim,
criar manualmente um algoritmo para resolver esta tarefa pode ser extremamente
complexo ou até mesmo impraticável. A partir deste contexto, surgiu a área de
\textbf{aprendizado de máquina}, que estuda algoritmos que fornecem a programas
de computador a habilidade de aprender e se aperfeiçoarem, tornando-os capazes
de resolver tarefas sem serem explicitamente programados.

Existem três tipos principais de aprendizado de máquina\cite[cap.
18]{RussellNorvig200912}, que são diferenciados entre sí pelo tipo de
\textit{feedback} retornado pelo problema. Estas categorias são:
\textbf{aprendizado supervisionado}, \textbf{aprendizado não-supervisionado} e
\textbf{aprendizado por reforço}. No aprendizado supervisionado, é fornecido um
conjunto de dados com exemplos de entrada e resultados esperados para aquelas
entradas. Assim, a tarefa neste tipo de aprendizado consiste em aprender uma
função que mapeia entradas para saídas. No aprendizado não-supervisionado, o
programa recebe um conjunto de dados de entrada mas não recebe informações com o
tipo de saída esperado. O objetivo deste tipo de aprendizado geralmente é
detectar padrões em conjuntos de dados.  O último tipo de aprendizado, o
aprendizado por reforço, é diferente dos demais porque está diretamente ligado
ao conceito de agentes racionais.  Neste tipo de aprendizado, o agente interage
com um ambiente dinâmico e deve atingir algum objetivo. Quando o agente executa
ações no ambiente, é fornecido a ele algum tipo de retorno -- recompensas ou
punições --, para que ele possa aprender a agir da maneira correta a fim de
atingir seus objetivos.

Para agentes racionais, a capacidade de aprender fornece a oportunidade de se
tornar mais competente que o permitido pelo seu conhecimento inicial do problema
e do ambiente. Problemas como informação incompleta ou inexistente sobre o
ambiente são mais facilmente contornados, pois o agente será capaz de criar um
modelo de representação através do retorno obtido após a execução de ações.


%----------
\section{\label{section:neural-networks}Redes Neurais}


%----------
\section{\label{section:environment}Algoritmos Genéticos}

% NEAT
% neuroevolução
% NEAT evolui os pesos e a rede em sí (TWEANNs)
% representação genética da rede
% problemas comuns em TWEANNs que o NEAT resolve
% (competing conventions, protecting innovation e initial population)

%----------
\section{\label{section:behavior-trees}Behavior Trees}
Tomar decisões é uma das tarefas mais importantes na construção de bons agentes
inteligentes. Em um contexto de jogos digitais, por exemplo, a partir de 1990, o
uso de inteligência artificial em jogos passou a ser um diferencial no momento
da compra de um jogo \cite[Cap 1.]{Millington:2009:AIG:1795711}. Portanto,
escolher uma boa técnica para o processo de tomada de decisão pode ser um dos
fatores de sucesso na construção de agentes. Das técnicas mais populares,
\textit{\textbf{behavior trees}} (árvores de comportamento) é uma das que mais
se destaca por sua \textbf{simplicidade} e \textbf{extensibilidade} \cite[Cap.
4]{Rabin:2013:GAP:2566761}, além de ter sido utilizada na indústria em jogos
como \textbf{Halo 2} \cite[Cap.  5]{Millington:2009:AIG:1795711}, por exemplo.

Uma \textit{behavior tree} é uma estrutura de dados baseada em árvore, contendo
um nodo raíz e vários nodos filhos que representam um \textbf{comportamento}
(\textit{behavior}). Cada nodo filho pode ter outros filhos, formando assim uma
árvore. Cada um desses comportamentos deve ter uma \textit{pré-condição} e uma
\textit{ação}. Caso a pré-condição seja satisfeita, o agente poderá executar o
comportamento descrito pela ação do nodo \cite[Cap 4.]{Rabin:2013:GAP:2566761}.
Isso faz com que o algoritmo seja bastante simples, partimos do nodo raíz em
busca do primeiro filho que satisfaça a sua pré-condição. Ao encontrar esse
filho, é executada a sua ação. É importante ressaltar que somente um
comportamento é selecionado por vez. Portanto, se um comportamento for
selecionado, o algoritmo não tentará executar as ações dos nodos vizinhos na
mesma execução do algoritmo.

Como este é um formalismo bastante simples, é possível, por exemplo, adicionar
estruturas de \textbf{controle de fluxo} a ele. Dessa forma, os ramos da árvore
passam a ser usados para controlar o fluxo de execução, enquanto os nodos folhas
representam as pré-condições e ações \cite[Cap.  10]{Rabin:2015:GAP:2821138}.
Isso permite que diversos tipos de controle de fluxo sejam aplicados. Assim,
cada vez que a ação de um nodo folha é executada, é informado ao pai (ramo de
controle de fluxo) o estado dessa ação, se foi executada com sucesso ou falha ou
se ainda está em execução.  Existem alguns desenvolvedores que informam ao pai
outras informações, como por exemplo, o motivo do erro. Isso permite que o pai
decida o que fazer baseado nessas informações. Existem vários algoritmos para a
realização do controle de fluxo, dentre os mais comumente utilizados estão o
algoritmo de \textbf{seleção} e o de \textbf{sequência}. O algoritmo de
\textbf{seleção} faz a execução do \textbf{primeiro} nodo filho que tiver sua
pré-condição satisfeita. Um exemplo do algoritmo pode ser visto no algoritmo
\ref{alg:behavior-tree-selection}.

\begin{algorithm}[H]
\begin{center}
	% Um exemplo de algoritmo utilizando a pacote 'algorithmic'
	%\algsetup{linenosize=\small,linenodelimiter=.}
	\begin{algorithmic}[1]
        \STATE filhos $\gets$ lista de nodos filhos
        \FOR{cada filho em filhos}
            \IF{filho.executar() == true}
                \RETURN true
            \ENDIF
        \ENDFOR
        \RETURN false
    \end{algorithmic}
\end{center}
\caption[Algoritmo para execução do controle de fluxo do tipo seleção em uma
behavior tree.]
{\label{alg:behavior-tree-selection} Algoritmo para execução do controle de
fluxo do tipo seleção em uma behavior tree.}
\end{algorithm}

Diferentemente do algoritmo de seleção, o algoritmo de \textbf{sequência}
tentará executar todos os nodos que satisfizerem suas pré-condições de forma
sequencial. Portanto, esse algoritmo tentará tomar a ação descrita pelo primeiro
nodo, caso isso seja possível, tentará executar a ação do segundo nodo, e assim
sucessivamente. Sua execução é interrompida quando não for possível tomar a ação
descrita pelo nodo ou quando não existirem mais nodos para se avaliar. O
algoritmo é bastante parecido com o algoritmo de seleção, sendo exemplificado no
algoritmo \ref{alg:behavior-tree-sequence}.

\begin{algorithm}[H]
\begin{center}
	% Um exemplo de algoritmo utilizando a pacote 'algorithmic'
	%\algsetup{linenosize=\small,linenodelimiter=.}
	\begin{algorithmic}[1]
        \STATE filhos $\gets$ lista de nodos filhos
        \FOR{cada filho em filhos}
            \IF{filho.executar() == false}
                \RETURN false
            \ENDIF
        \ENDFOR
        \RETURN true
    \end{algorithmic}
\end{center}
\caption[Algoritmo para execução do controle de fluxo do tipo sequência em uma
behavior tree.]
{\label{alg:behavior-tree-sequence} Algoritmo para execução do controle de fluxo
do tipo sequência em uma behavior tree.}
\end{algorithm}

A figura \ref{fig:behavior-tree-example} representa através de uma
\textit{behavior tree} com o uso de fluxo de controle um agente que deve
recarregar suas energias e, após isso, limpar a casa. Os retângulos de fundo
branco representam as ações, os retângulos com bordas arredondadas, as
estruturas de controle e os com fundo preto as pré-condições. Nesse exemplo,
caso o agente esteja com pouca energia, será possível carregar suas baterias
através de \textit{energia solar}. Se essa ação falhar -- em um dia chuvoso, por
exemplo -- será possível então utilizar \textit{energia elétrica}. Isso é feito
pelo controle de fluxo \textbf{selecionar}, que testa cada uma das ações e
executa a que for possível de ser executada.  No momento em que o agente vai
limpar a casa, caso a casa esteja suja, o agente limpará a sala e organizará os
móveis de forma sequencial -- ou seja, é necessário estar com a sala limpa para
organizar os móveis. Isso é feito pelo controle de fluxo \textbf{sequência}.

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    every node/.style={
        font=\footnotesize
    },
    composite/.style={
        minimum width=1.75cm, minimum height=1.2cm,
        text width=1.75cm,
        text centered,
        rounded rectangle,
        draw
    },
    action/.style={
        minimum width=1.75cm, minimum height=1.2cm,
        text width=1.75cm,
        text centered,
        rectangle,
        draw
    },
    precond/.style={
        minimum width=1.75cm, minimum height=1.2cm,
        text width=1.75cm,
        text centered,
        rectangle,
        fill=black,
        text=white
    }
]
\matrix [row sep=1cm, column sep=0.3cm] {
                                                &
                                                &
                                                &
    \node (n1)  [action]    {Raíz};             &
                                                &
                                                &
                                                &
    \\
                                                &
    \node (n2)  [composite] {Selecionar};       &
                                                &
    \node (n3)  [action]    {Descansar};        &
                                                &
    \node (n4)  [composite] {Sequência};        &
                                                &
                                                &
    \\
    \node (n5)  [precond]   {Pouca Energia?};   &
    \node (n6)  [action]    {Energia Elétrica}; &
    \node (n7)  [action]    {Energia Solar};    &
                                                &
    \node (n8)  [precond]   {Casa Suja?};       &
    \node (n9)  [action]    {Limpar Sala};      &
    \node (n10) [action]    {Organizar Móveis}; &
    \\
};
\draw[->,>=latex] (n1.south) -- (n2.north);
\draw[->,>=latex] (n1.south) -- (n3.north);
\draw[->,>=latex] (n1.south) -- (n4.north);

\draw[->,>=latex] (n2.south) -- (n5.north);
\draw[->,>=latex] (n2.south) -- (n6.north);
\draw[->,>=latex] (n2.south) -- (n7.north);

\draw[->,>=latex] (n4.south) -- (n8.north);
\draw[->,>=latex] (n4.south) -- (n9.north);
\draw[->,>=latex] (n4.south) -- (n10.north);
\end{tikzpicture}
\caption {\label{fig:behavior-tree-example}Exemplo de uma \textit{behaviour
tree} para representar um agente que deve carregar suas baterias caso seja
necessário, além de limpar e organizar a casa, descansando caso contrário.}
\end{figure}

Existem algumas outras técnicas que resolvem o mesmo problema que as
\textit{behavior trees}. Por exemplo, as \textbf{\textit{finite state machines}}
(máquinas de estados finitos) são muito utilizadas em inteligência artificial,
pois trazem estruturas bastante simples de implementar e muito poderosas no
momento de sua utilização. Contendo \textit{estados} que são ligados através de
\textit{transições}, essa estrutura faz com que modelar uma inteligência
artifical seja bastante simples. O problema dessa abordagem está quando
precisamos reutilizar estados. Como uma transição liga apenas dois estados, é
impossível utilizar o mesmo estado sem duplicá-lo. Para resolver esse problema,
existe uma técnica baseada nessa chamada de \textbf{\textit{hierarchical finite
state machines}} (máquinas de estados finitos hierárquicos). Essa estrutura
permite que estados sejam englobados em outros estados, resolvendo o problema de
reutilização.  Entretanto, ambas abordagens ainda são de difícil extensão. Como
um estado está ligado à outro via uma transição, adicionar e remover estados
dessa estrutura pode ser um problema, principalmente quando o modelo construído
inicialmente não é adequado para o que estamos resolvendo, sendo necessário
realizar muitas mudanças de forma a testar outras soluções possíveis.


%----------
\section{\label{section:neat}NEAT}
\begin{mdframed}[backgroundcolor=green!20]
\begin{itemize}
    \item
        Introdução: Escolha da técnica, história, paper
    \item
        Relação com aprendizado de máquina
    \item
        Relação com algoritmos genéticos
    \item
        Relação com redes neurais
    \item
        Explicação sobre a técnica: detalhamento de como funciona, termos
        técnicos, exemplos, pedaços de código (se necessário)
    \item
        Como será utilizada na construção dos \textit{bots}
\end{itemize}
\end{mdframed}
