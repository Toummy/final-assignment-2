\chapter{\label{chap:theory}Fundamentação Teórica}
Neste capítulo, apresentaremos a base teórica necessária para compreender o
funcionamento das técnicas de inteligência artificial escolhidas para realizar o
desenvolvimento dos agentes inteligentes de \textit{Spelunky}.


%----------
\section{\label{section:environment}Ambientes}
Todas as percepções e ações executadas por agentes racionais ocorrem no
\textbf{ambiente} no qual ele está inserido. A quantidade e variedade de
ambientes encontrados é vasta, mas é possível identificar dimensões (ou
características) de classificação para realizar uma categorização destes
ambientes. Estas características irão determinar que tipos de agentes --
enumerados na seção \ref{section:agents} -- são apropriados para cada ambiente.
As dimensões utilizadas para categorizar ambientes são:

\begin{description}
	\item[Observável, Parcialmente Observável ou Não-Observável]
		Um ambiente é observável se os sensores do agente lhe permitirem acesso
		completo ao estado do ambiente a cada ponto no tempo. Ambientes
		observáveis são convenientes, pois o agente não precisa manter um estado
		interno de conhecimento para se manter informado. O ambiente é
		parcialmente observável se os sensores do agente possuirem ruído ou não
		tiverem acesso completo ao ambiente. Se o agente não possuir nenhum tipo
		de sensor, então o ambiente é não-observável.

	\item[Agente Único ou Multi-Agente]
		Quando o agente não precisa interagir com nenhum outro agente no
		ambiente, então trata-se de um ambiente com agente único. Caso ele
		precise interagir de alguma forma (competição, cooperação ou
		comunicação) com outros agentes, então o ambiente é multi-agente.

	\item[Determinístico ou Estocástico]
		Se o próximo estado do ambiente for completamente determinado pela
		combinação do estado atual com uma ação executada pelo agente, então o
		ambiente é determinístico. Caso contrário, é estocástico.

	\item[Episódico ou Sequencial]
		Em ambientes episódicos, a experiência do agente é dividida em episódios
		atômicos, ou seja, são independentes entre sí. O agente não precisa
		pensar adiante pois, a cada episódio, recebe informações sensoriais e
		executa apenas uma ação, e o próximo episódio não será influenciado pela
		ação anterior. Já em ambientes sequenciais, a ação atual pode
		influenciar todas as decisões futuras, ou seja, ações a curto prazo
		podem ter consequências a longo prazo.

	\item[Discreto ou Contínuo]
		Ambientes discretos são aqueles onde se tem um número contável de ações
		e percepções possíveis. Em ambientes contínuos, o número de ações e de
		percepções muitas vezes são baseados em valores contínuos ou não são
		contáveis.

	\item[Conhecido ou Desconhecido]
		Esta distinção não se refere ao ambiente em sí, e sim sobre o
		conhecimento do agente (ou criador do agente) das "leis" de
		comportamento do ambiente. Em um ambiente conhecido, os resultados (ou
		probabilidades de resultados) das ações são conhecidos. Quando o
		ambiente é desconhecido, o agente precisa primeiro aprender como o
		ambiente funciona para saber fazer escolhas boas para atingir seus
		objetivos.
\end{description}


%----------
\section{\label{section:agents}Agentes Racionais}
Um agente é uma entidade que utiliza seus \textbf{sensores} para perceber o
ambiente no qual está inserido e interage através de seus \textbf{atuadores},
direcionando seus esforços para alcançar algum objetivo que se propõe a
atingir\cite[cap. 2]{RussellNorvig200912}. Um exemplo de agente racional é o ser
humano, que percebe o ambiente através de seus sentidos (visão, audição, entre
outros) e executa ações com seu corpo (braços, pernas, etc.). De acordo com
Russell \& Norvig\cite{RussellNorvig200912}, agentes racionais são agrupados nas
seguintes categorias: \textbf{agentes reflexivos}, \textbf{agentes baseados em
modelo}, \textbf{agentes baseados em objetivos} e \textbf{agentes baseados em
utilidade}.

Os \textbf{agentes reflexivos} são programados para executar ações baseadas em
algum evento percebido. Fica evidente que este tipo de agente simplesmente
executa uma ação baseado em suas percepções imediatas e não guardam informações
sobre suas experiências passadas, sendo apenas reativos.

Diferentemente dos agentes reflexivos, \textbf{agentes baseados em modelo} são
capazes de guardar informações sobre suas experiências passadas e sobre seu
estado atual. Este tipo de agente compreende como suas ações modificam o
ambiente onde está inserido e como o ambiente se altera independentemente de
suas ações, efetivamente construíndo um \textbf{modelo} do ambiente. 

Às vezes, ter conhecimento sobre o estado atual do ambiente não é suficiente
para decidir que ação executar. O agente precisa de alguma informação de que
situações são desejáveis, ou que objetivos desejar cumprir. Este é o caso de
\textbf{agentes baseados em objetivo}, que combinam um modelo do ambiente com
informações de objetivo para escolher as ações que mais o aproximam dos estados
desejáveis. A escolha de ações baseada em objetivos pode ser simples -- quando,
por exemplo, o objetivo é antigido com a execução de apenas uma ação -- ou
complexo -- quando, por exemplo, o agente deve considerar longas cadeias de
ações para atingir seus objetivos.

Em alguns casos, os objetivos não são suficientes para gerar comportamentos de
alta qualidade. Por exemplo, muitas vezes é possível atingir um objetivo através
de várias sequências de ações, mas algumas sequências são mais rápidas, mais
seguras, mais confiáveis ou mais baratas. Os \textbf{agentes baseados em
utilidade} fazem uso de uma função de utilidade para medir sua performance e,
assim, distinguir estados mais desejáveis e menos desejáveis. O agente, então, é
capaz de escolher as ações mais vantajosas para ele, aumentando sua performance.


%----------
\section{\label{section:machine-learning}Aprendizado de Máquina}
Quando queremos resolver um problema através de um programa de computador,
desenvolvemos um algoritmo que, dado uma entrada, executa uma sequência de
operações para fornecer uma resposta adequada para a tarefa em questão. Um
exemplo disso seriam os algoritmos para ordenação de números, onde a entrada é
um conjunto de números e a resposta é o conjunto ordenado. Para alguns
problemas, contudo, nem sempre é possível se chegar a um algoritmo que resolve
satisfatóriamente uma tarefa. Por exemplo, a tarefa de diferenciar
\textit{e-mails} de \textit{spam} e \textit{e-mails} legítimos é complexa, pois
os \textit{e-mails} de \textit{spam} estão mudando constantemente, e a
categorização de \textit{spam} pode variar de indivíduo para indivíduo. Assim,
criar manualmente um algoritmo para resolver esta tarefa pode ser extremamente
complexo ou até mesmo impraticável. A partir deste contexto, surgiu a área de
\textbf{aprendizado de máquina}, que estuda algoritmos que fornecem a programas
de computador a habilidade de aprender e se aperfeiçoarem, tornando-os capazes
de resolver tarefas sem serem explicitamente programados.

Existem três tipos principais de aprendizado de máquina\cite[cap.
18]{RussellNorvig200912}, que são diferenciados entre sí pelo tipo de
\textit{feedback} retornado pelo problema. Estas categorias são:
\textbf{aprendizado supervisionado}, \textbf{aprendizado não-supervisionado} e
\textbf{aprendizado por reforço}. No aprendizado supervisionado, é fornecido um
conjunto de dados com exemplos de entrada e resultados esperados para aquelas
entradas. Assim, a tarefa neste tipo de aprendizado consiste em aprender uma
função que mapeia entradas para saídas. No aprendizado não-supervisionado, o
programa recebe um conjunto de dados de entrada mas não recebe informações com o
tipo de saída esperado. O objetivo deste tipo de aprendizado geralmente é
detectar padrões em conjuntos de dados.  O último tipo de aprendizado, o
aprendizado por reforço, é diferente dos demais porque está diretamente ligado
ao conceito de agentes racionais.  Neste tipo de aprendizado, o agente interage
com um ambiente dinâmico e deve atingir algum objetivo. Quando o agente executa
ações no ambiente, é fornecido a ele algum tipo de retorno -- recompensas ou
punições --, para que ele possa aprender a agir da maneira correta a fim de
atingir seus objetivos.

Para agentes racionais, a capacidade de aprender fornece a oportunidade de se
tornar mais competente que o permitido pelo seu conhecimento inicial do problema
e do ambiente. Problemas como informação incompleta ou inexistente sobre o
ambiente são mais facilmente contornados, pois o agente será capaz de criar um
modelo de representação através do retorno obtido após a execução de ações.


%----------
\section{\label{section:neural-networks}Redes Neurais Artificiais}
Uma \textbf{rede neural artificial} é um modelo matemático que busca replicar
computacionalmente (através de aproximações de funções) as capacidades de
processamento de informações de sistemas nervosos
biológicos\cite{Rojas:1996:NNS:235222}. Recentemente, redes neurais artificiais
vem recebendo uma atenção especial, mas esta técnica teve suas origens no início
da década de 40\cite{RussellNorvig200912}. Esta seção apresenta apenas um resumo
geral de redes neurais artificiais, pois o assunto é muito complexo e um
entendimento superficial do funcionamento desta técnica é suficiente para este
trabalho.

Os elementos mais primitivos das redes neurais são as unidades de processamento
chamadas \textbf{neurônios} -- ilustrado na Figura
\ref{fig:neural-networks-neurons}.  Cada neurônio possui canais de
\textbf{entrada} através dos quais recebe as informações que deverá processar.
Cada canal de entrada possui um \textbf{peso}, que informa ao neurônio o quão
relevante a informação advinda daquela conexão é importante. Com estas
informações em mãos, realiza um processamento interno através de sua
\textbf{função de ativação}. Depois, envia a informação processada adiante, ou
para mais processamento em neurônios adicionais, ou como resultado final da
operação.

Para processar as informações do problema (e, assim, gerar uma função da rede),
as redes neurais organizam as conexões e localizações de seus neurônios de uma
maneira específica, formando uma \textbf{topologia} da rede. Basicamente, 

\begin{figure}[H]
\centering
\caption {\label{fig:neural-networks-neuron}Ilustração que indica os principais
componentes de um neurônio de uma rede neural artificial.}
\end{figure}


\begin{mdframed}[backgroundcolor=green!20]
\begin{itemize}
	\item
		Explicar
\end{itemize}
\end{mdframed}



%----------
\section{\label{section:environment}Algoritmos Evolutivos}
\begin{mdframed}[backgroundcolor=green!20]
\begin{itemize}
	\item
		Explicar
\end{itemize}
\end{mdframed}



%----------
\section{\label{section:behavior-trees}Behavior Trees}
A construção de bons agentes inteligentes depende fortemente da capacidade que
os agentes têm de tomar boas decisões de comportamento. No contexto de jogos
digitais, a partir da década de 90, a qualidade da inteligência artificial
passou a ser um diferencial no momento de compra de um jogo\cite[Cap.
1]{Millington:2009:AIG:1795711}, aumentando a importância da escolha de uma
técnica apropriada para desenvolver os agentes inteligentes.Das técnicas mais
populares, a \textbf{\textit{Behavior Tree}}, ou Árvore de Comportamento, é uma
das técnicas que mais se destaca, devido a sua \textbf{simplicidade} e
\textbf{extensibilidade}\cite[Cap.  4]{Rabin:2013:GAP:2566761}, e já foi
utilizada na indústria em jogos como \textit{Halo 2}\cite[Cap.
5]{Millington:2009:AIG:1795711} e
\textit{Spore}\footnote{http://chrishecker.com/My\_liner\_notes\_for\_spore},
por exemplo.

Uma \textit{Behavior Tree} é uma estrutura de dados baseada em árvore que contém
um nodo \textbf{raíz} (geralmente utilizada para controlar o fluxo inicial de
execução) e vários nodos filhos que representam os \textbf{comportamentos}. Cada
comportamento deve possuir uma \textbf{pré-condição} e uma \textbf{ação}. Caso a
pré-condição seja satisfeita, o agente poderá executar o comportamento descrito
pela ação do nodo\cite[Cap. 4]{Rabin:2013:GAP:2566761}. Isto faz com que o
algoritmo de execução seja simples: partimos do nodo raíz em busca do primeiro
filho que satisfaça sua pré-condição (geralmente da esquerda para a direita). Ao
encontrá-lo, executamos sua ação. É importante ressaltar que somente um
comportamento é selecionado por vez. Portanto, se um comportamento for
selecionado, o algoritmo não tentará executar as ações dos nodos vizinhos na
mesma execução do algoritmo.

É possível adicionar estruturas de \textbf{controle de fluxo} a uma
\textit{Behavior Tree}. Desta forma, os ramos da árvore passam a ser usados para
controlar o fluxo de execução, enquanto os nodos-folha representam as
pré-condições e ações\cite[Cap. 10]{Rabin:2015:GAP:2821138}. Quando uma ação de
um nodo-folha é executado, ele informa ao seu pai (controlador de fluxo) o
estado de sua execução -- sucesso, falha ou em andamento. Existem diversos
tipos de estruturas de controle de fluxo que são utilizadas em \textit{Behavior
Trees}, mas as mais comuns são os de \textbf{seleção} e de \textbf{sequência}.

O algoritmo do controle de fluxo de seleção -- exemplificado no algoritmo
\ref{alg:behavior-tree-selection} -- faz a execução do \textbf{primeiro nodo
filho} que tiver sua pré-condição satisfeita. Quando termina de executar a ação
selecionada, aborta o procedimento, não visitando as demais ações.
Diferentemente do algoritmo de seleção, o algoritmo de \textbf{sequência} --
exemplificado no algoritmo \ref{alg:behavior-tree-sequence} -- tentará executar
\textbf{todos} os nodos que satisfizerem suas pré-condições de forma
\textbf{sequencial}. Sua execução só é interrompida quando não for possível
tomar a ação descrita pelo nodo ou quando não existirem mais nodos para se
avaliar.

\begin{algorithm}[H]
\begin{center}
	% Um exemplo de algoritmo utilizando a pacote 'algorithmic'
	%\algsetup{linenosize=\small,linenodelimiter=.}
	\begin{algorithmic}[1]
        \STATE filhos $\gets$ lista de nodos filhos
        \FOR{cada filho em filhos}
            \IF{filho.executar() == true}
                \RETURN true
            \ENDIF
        \ENDFOR
        \RETURN false
    \end{algorithmic}
\end{center}
\caption[Algoritmo para execução do controle de fluxo do tipo seleção em uma
behavior tree.]
{\label{alg:behavior-tree-selection} Algoritmo para execução do controle de
fluxo do tipo seleção em uma behavior tree.}
\end{algorithm}

\begin{algorithm}[H]
\begin{center}
	% Um exemplo de algoritmo utilizando a pacote 'algorithmic'
	%\algsetup{linenosize=\small,linenodelimiter=.}
	\begin{algorithmic}[1]
        \STATE filhos $\gets$ lista de nodos filhos
        \FOR{cada filho em filhos}
            \IF{filho.executar() == false}
                \RETURN false
            \ENDIF
        \ENDFOR
        \RETURN true
    \end{algorithmic}
\end{center}
\caption[Algoritmo para execução do controle de fluxo do tipo sequência em uma
behavior tree.]
{\label{alg:behavior-tree-sequence} Algoritmo para execução do controle de fluxo
do tipo sequência em uma behavior tree.}
\end{algorithm}

Para que fique mais claro como a técnica é utilizada, criamos um cenário
hipotético onde devemos criar a inteligência artificial de um agente (um robô
doméstico) que tem uma tarefa muito importante: limpar e organizar os móveis da
sala de estar de uma casa. Este robô, contudo, é movido à baterias, que não
duram muito. Então, de tempos em tempos, é necessário que ele recarregue suas
energias. Existem duas fontes de energia disponíveis para o robô: energia solar
e energia elétrica. A energia solar é preferível, por ser uma forma de energia
mais limpa, mas nem sempre é possível utilizá-la (um dia chuvoso, por exemplo).
Caso o robô termine suas tarefas e não esteja com níveis baixos de bateria, pode
descansar, entrando em modo de repouso.  A Figura
\ref{fig:behavior-tree-example} representa o comportamento deste agente através
de uma \textit{Behavior Tree}. Para decidir entre as fontes de energia, usamos
um controle de fluxo do tipo \textbf{seleção}, pois somente um tipo de energia
deve ser utilizado. Já para executar suas tarefas (limpar e organizar), usamos
um controle de fluxo do tipo \textbf{sequência}, pois todas as tarefas devem ser
executadas.

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    every node/.style={
        font=\scriptsize
    },
    composite/.style={
        minimum width=1.3cm, minimum height=1.2cm,
        text width=1.3cm,
        text centered,
        rounded rectangle,
        draw
    },
    action/.style={
        minimum width=1.3cm, minimum height=1.2cm,
        text width=1.3cm,
        text centered,
        rectangle,
        draw
    },
    precond/.style={
        minimum width=1.3cm, minimum height=1.2cm,
        text width=1.3cm,
        text centered,
        rectangle,
        fill=black,
        text=white
    }
]
\matrix [row sep=1cm, column sep=0.3cm] {
                                                &
                                                &
                                                &
    \node (n1)  [action]    {Raíz};             &
                                                &
                                                &
                                                &
                                                &
                                                &
    \\
                                                &
    \node (n2)  [composite] {Selecionar};       &
                                                &
                                                &
    \node (n4)  [composite] {Sequência};        &
                                                &
    \node (n3)  [action]    {Descansar};        &
                                                &
                                                &
    \\
    \node (n5)  [precond]   {Pouca Energia?};   &
    \node (n7)  [action]    {Energia Solar};    &
    \node (n6)  [action]    {Energia Elétrica}; &
    \node (n8)  [precond]   {Casa Suja?};       &
    \node (n9)  [action]    {Limpar Sala};      &
    \node (n10) [action]    {Organizar Móveis}; &
                                                &
                                                &
                                                &
    \\
};
\draw[->,>=latex] (n1.south) -- (n2.north);
\draw[->,>=latex] (n1.south) -- (n3.north);
\draw[->,>=latex] (n1.south) -- (n4.north);

\draw[->,>=latex] (n2.south) -- (n5.north);
\draw[->,>=latex] (n2.south) -- (n6.north);
\draw[->,>=latex] (n2.south) -- (n7.north);

\draw[->,>=latex] (n4.south) -- (n8.north);
\draw[->,>=latex] (n4.south) -- (n9.north);
\draw[->,>=latex] (n4.south) -- (n10.north);
\end{tikzpicture}
\caption {\label{fig:behavior-tree-example}Exemplo de uma \textit{behaviour
tree} para representar um agente que deve carregar suas baterias caso seja
necessário, além de limpar e organizar a casa, descansando caso contrário.}
\end{figure}

Existem algumas outras técnicas que resolvem o mesmo problema que as
\textit{Behavior Trees} como, por exemplo, as \textbf{\textit{Finite State
Machines}} (máquinas de estados finitos), que são muito utilizadas em
inteligência artificial para jogos. Uma \textit{FSM} contém \textbf{estados} que
são ligados através de \textbf{transições}. Contudo, existem diversos problemas
com esta abordagem. A quantidade de estados e transições cresce
exponencialmente, os estados não podem ser reutilizados com facilidade e devemos
nos preocupar constantemente se existem transições inválidas no modelo. As
\textit{FSMs} possuem, resumidamente, um problema de modularidade.

Outra técnica muito utilizada são as \textbf{\textit{Hierarchical Finite State
Machines}} (máquinas de estados finitos hierárquicas). O objetivo da criação
desta técnica foi justamente mitigar alguns dos problemas das \textit{FSMs},
permitindo o englobamento de estados em uma hierarquia. Entretanto, o problema
de extensibilidade e praticidade ainda existem, porque ainda é baseada em
transições.


%----------
\section{\label{section:neat}NEAT}
% NEAT
% neuroevolução
% NEAT evolui os pesos e a rede em sí (TWEANNs)
% representação genética da rede
% problemas comuns em TWEANNs que o NEAT resolve
% (competing conventions, protecting innovation e initial population)

\begin{mdframed}[backgroundcolor=green!20]
\begin{itemize}
    \item
        Introdução: Escolha da técnica, história, paper
    \item
        Relação com aprendizado de máquina
    \item
        Relação com algoritmos genéticos
    \item
        Relação com redes neurais
    \item
        Explicação sobre a técnica: detalhamento de como funciona, termos
        técnicos, exemplos, pedaços de código (se necessário)
    \item
        Como será utilizada na construção dos \textit{bots}
\end{itemize}
\end{mdframed}
