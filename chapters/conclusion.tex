\chapter{\label{chap:conclusion}Conclusão}

%Conclusion: here, you summarize what are your contributions and how you
%envision them going forward
%	Contributions: what did you achieve in this work?
%	Limitations: what are any problems or limitations to your contribution?
%	Future work: what can be done to improve your work?

% ---------------------

%contribuicoes
Após a realização deste estudo, percebemos que \textit{Spelunky} é, de fato, um
jogo de computador muito interessante para a aplicação de técnicas de
Inteligência Artificial, pois ainda possui muitos domínios de problema em
aberto, inclusive o de navegação, que foi o foco deste trabalho. A complexidade
de \textit{Spelunky} também o diferencia de jogos tradicionais do gênero
\textit{platformer}, portanto toda contribuição para avançar na solução de
qualquer domínio de problema do jogo é de imensa importância.

Analisando os resultados obtidos no Capítulo
\ref{chap:experimentation-and-results}, fica claro que é possível utilizar a
neuroevolução (evolução de redes neurais artificiais através de algoritmos
genéticos), mais especificamente a técnica \textit{NeuroEvolution of Augmenting
Topologies}, para criar agentes inteligentes capazes de jogar com autonomia o
jogo de computador \textit{Spelunky}.

A técnica \textit{NEAT} possui um papel central neste trabalho pois, conforme
mencionado no Capítulo \ref{chap:theory}, ela resolve uma série de problemas que
afetam os algoritmos evolutivos. O armazenamento da origem histórica dos genes,
através do número de inovação, faz com que a técnica não sofra com o problema da
permutação. O sistema de especiação restringe a competição dentro da população,
o que efetivamente protege a sobrevivência de organismos inovadores. Por fim, a
inicialização da população inicial de maneira mínima cria uma tendência pela
procura de uma solução por espaços com dimensões reduzidas e ajuda a garantir
que somente modificações úteis para os organismos sobreviverão.  A utilização
deste técnica para desenvolver agentes inteligentes é, portanto, uma ótima
escolha, o que fica evidenciado tanto pelos resultados deste trabalho quanto
pelos trabalhos relacionados citados no Capítulo \ref{chap:related-work}.

Consideramos que este estudo é um aprofundamento na pesquisa para a solução do
domínio de navegação de \textit{Spelunky} pois, se comparado aos demais
trabalhos com o mesmo propósito, analisados no Capítulo \ref{chap:related-work},
nossos cenários de teste são mais complexos e os resultados mais satisfatórios.
Além disso, uma característica importante a se ressaltar é que em nenhum momento
fornecemos informações privilegiadas para nossos agentes como, por exemplo, a
localização exata da porta de saída, o que torna nossa abordagem mais justa se
comparada ao desempenho de um jogador humano.

Para contornar as limitações da ferramenta \textit{SpelunkBots}, listadas no
Capítulo \ref{chap:modeling}, tomamos uma série de decisões de modelagem para
tentar, ao máximo, viabilizar o treinamento dos agentes. Ao restringir o campo
de visão e as ações possíveis, reduzimos consideravelmente a complexidade das
redes neurais dos agentes. Não obstante, criamos mecanismos para tentar agilizar
o processo de aprendizado, como a formulação do neurônio de detecção de
obstáculos, que foram bem sucedidos. Os testes com mais de uma função de aptidão
nos permitiram compreender ainda mais a importância da escolha e experimentação
de diferentes parâmetros e regras para calcular a aptidão dos agentes. A
identificação de agentes não promissores também nos concedeu uma forma de
agilizar ainda mais a execução dos experimentos.

Outros pontos importantes de destaque neste trabalho são as modificações
realizadas na ferramenta \textit{SpelunkBots}. Como o jogo \textit{Spelunky} foi
desenvolvido utilizando uma versão muito antiga do \textit{GameMaker}, a
ferramenta, originalmente, só funcionava na plataforma \textit{Windows}. Um dos
frutos deste trabalho é, portanto, a adaptação do \textit{SpelunkBots} para a
plataforma de desenvolvimento \textit{Linux}. As demais modificações, como pular
diretamente para o treinamento, a externalização das configurações da ferramenta
e a inclusão da possibilidade de exeução com \textit{display} virtual, agilizam
o processo de desenvolvimento e permitem a execução do programa em um servidor
dedicado. Por conseguinte, encaramos nossas modificações como uma ampliação das
possibilidades de desenvolvimento para futuros pesquisadores e desenvolvedores
que optem por utilizar esta ferramenta.

%limitacoes
Infelizmente, devido a uma restrição de tempo, não foi possível realizar a
execução de todos os experimentos previstos neste trabalho, mais especificamente
o experimento no cenário difícil.  Apesar de todas as limitações de modelagem
que impusemos e as melhorias que fizemos na ferramenta \textit{SpelunkBots}, a
velocidade de execução dos testes continuou sendo o maior problema a se
enfrentar durante a elaboração deste trabalho. Como a execução dos testes se dá
praticamente em tempo real de execução do jogo, torna-se inviável realizar
experimentos que demorem muito tempo para concluir.

Uma das consequências das limitações de performance do \textit{SpelunkBots},
conforme mencionada no Capítulo \ref{chap:modeling}, é que caso ocorra qualquer
queda de desempenho momentânea, a contabilização de tempo continuará igual. Isto
imediatamente aponta para dois problemas. O primeiro é que máquinas com
capacidade de processamento inferiores não possuem, realisticamente falando, o
mesmo tempo de execução que máquinas mais potentes. O segundo é que não é
possível garantir, com 100\% de fidelidade, a reprodutibilidade de nossos
experimentos, pois qualquer alteração em partes do sistema que o programador não
possui controle, como o escalonamento ou priorização de processos, causaria um
impacto nos resultados dos testes.

A aplicação de \textit{Behavior Trees} para a criação de agentes inteligentes
estava prevista para este trabalho, mas não houve tempo hábil para explorar uma
segunda possibilidade algorítmica devido à limitação de tempo para a realização
deste estudo. Quando percebemos isso, optamos por redirecionar o foco deste
trabalho para uma avaliação mais aprofundada da utilização da técnica
\textit{NEAT}, o que nos forneceu mais tempo para realizar melhorias e executar
experimentos que não teríamos como realizar caso prosseguíssemos com nosso plano
original. Desta forma, a aplicação de \textit{Behavior Trees} para criação de
agentes inteligentes para \textit{Spelunky} permanece em aberto.


%----------
\section{Trabalhos Futuros}
Existem, sem dúvida alguma, muitos caminhos a serem explorados que podem vir a
fazer uso do conhecimento gerado neste trabalho. Como fechamento deste estudo
gostaríamos, portanto, de identificar algumas possibilidades de trabalhos
futuros para quaisquer desenvolvedores e pesquisadores que possam, por ventura,
ter interesse em dar continuidade a este projeto.

\textit{Spelunky} é uma excelente plataforma de testes para algoritmos e
técnicas de Inteligência Artificial e continua com diversos domínios de
problemas não tratados. Consideramos, em nosso trabalho, apenas o domínio de
navegação e, mesmo assim, impusemos diversas outras limitações. Uma possível
continuidade é, portanto, utilizar a técnica \textit{NEAT} e considerar outros
elementos do jogo, como inimigos, armas, tesouros, entre outros, enquanto
busca-se uma solução para a navegação.

Utilizamos a distância de Manhattan para calcular a aptidão de distância
percorrida, tomando como posição inicial e final a porta de entrada e a última
posição do jogador, respectivamente. Esta aproximação, como observamos em alguns
dos experimentos, pode ter como impacto a demora de aprendizado dos agentes,
pois muitas vezes os mapas possuem deslocamento em formato zigue-zague. É
possível que existam outras maneiras mais eficientes de se aproximar esta função
de aptidão. Uma sugestão seria tentar utilizar o algoritmo \textit{A*} para
calcular a distância entre os mesmos dois pontos. Esta nova aproximação aparenta
ser um pouco mais refinada e, pelo menos teoricamente, aponta uma possível
melhoria deste cálculo, o que poderia ser traduzido como uma aceleração da
velocidade de aprendizado e treinamento. Outra indicação seria experimentar com
diferentes pesos para os eixos $x$ e $y$ na distância de Manhattan.  A ideia é
dar mais importância para o deslocamento vertical e analisar o impacto deste
novo cálculo no desempenho dos agentes.

Até agora, todos os trabalhos de Inteligência Artificial aplicada a
\textit{Spelunky} buscaram resolver o problema de navegação. Outra opção de
trabalho futuro é abordar um problema diferente dentro do universo do jogo como,
por exemplo, aplicar algoritmos de Inteligência Artificial para criar
estratégias de alto nível para o jogo.

Atualmente, a execução de uma geração de organismos no \textit{NEAT} é feita
sequencialmente.  Contudo, o resultado de um organismo não influencia no
resultado de outros organismos pertencentes a mesma geração. Só é necessário
juntar os resultados obtidos quando se chega ao final da geração. Portanto, uma
possibilidade de estudo futuro é buscar a paralelização do algoritmo
\textit{NEAT} e utilizá-la para tratar algum domínio de problema de
\textit{Spelunky}.

Conforme identificado anteriormente, o maior impedimento deste trabalho foi o
gargalo de desempenho apresentado pela ferramenta \textit{SpelunkBots}. Na
situação atual, é extremamente inviável aplicar técnicas de Inteligência
Artificial que necessitem passar por um processo iterativo de treinamento, pois
não é possível acelerar a execução do programa. De certa forma, isto não é culpa
dos criadores da ferramenta, pois o desenvolvimento de \textit{SpelunkBots}
ocorreu em torno do código-fonte de \textit{Spelunky} que, por sua vez, está
atrelado ao motor de desenvolvimento de jogos \textit{GameMaker}. 

Ressaltamos, como uma das limitações de nosso trabalho, a incapacidade de
garantir completamente a reprodutibilidade dos experimentos. Isto porque
atualmente o cálculo de tempo decorrido é problemático. Uma possível melhoria é
encontrar uma forma alternativa de calcular o tempo decorrido, para corrigir
esta falha. Idealmente, este cálculo deve ser feito alterando o código-fonte de
\textit{Spelunky} e \textit{SpelunkBots} dentro do motor de desenvolvimento de
jogos \textit{GameMaker}. Esta mudança nos permitiria calcular exatamente quanto
tempo de execução o programa obteve, se o jogo está pausado, qual o estado do
jogador, entre outros.

É extremamente improvável que modificações no código do \textit{SpelunkBots}
resultem em melhorias significativas para a aplicação de algoritmos que
necessitam de treinamento, pois a magnitude de aceleração da simulação dos
testes precisa ser considerável. Assim, identificamos um possível trabalho
futuro relacionado a este problema: a reescrita do jogo \textit{Spelunky} com a
aplicação de técnicas de Inteligência Artificial em mente. Esta plataforma de
testes, idealmente, seria multiplataforma logo de início, pois assim atinge-se
um público alvo de desenvolvedores e pesquisadores maior. Além disso, deve ser
possível acelerar a simulação do jogo consideravelmente e executar o jogo sem
interface gráfica.

A técnica \textit{Behavior Tree} é extremamente manual e permite um controle
refinado do comportamento dos agentes. Além disso, as \textit{Behavior Trees}
são modulares, ou seja, é possível tratar subproblemas e, aos poucos,
incorporá-los em uma gigantesca árvore de comportamento. Como um dos objetivos
iniciais deste trabalho era aplicar \textit{Behavior Trees} no desenvolvimento
de agentes inteligentes de \textit{Spelunky}, não podemos deixar de sugerir esta
abordagem como um trabalho futuro.
