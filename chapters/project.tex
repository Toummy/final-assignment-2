\chapter{\label{chap:project}Projeto}

\todoin[caption={Melhorias para o capítulo}]
{
	\begin{itemize}
		\item O Problema
		\begin{itemize}
			\item Complexidade computacional de jogos
			\item Spelunky não é um platformer tradicional
			\begin{itemize}
				\item Níveis gerados proceduralmente (saída em lugares diferentes)
				\item Navegação horizontal e vertical
				\item Terreno destrutível
			\end{itemize}
			\item Domínio com diversos problemas a serem tratados
				\begin{itemize}
					\item Navegação
					\item Combate
					\item Planejamento e Estratégias
				\end{itemize}
		\end{itemize}

		\item Objetivos
		\begin{itemize}
			\item Detalhar qual problema queremos explorar
			\item Utilizar técnica NEAT para desenvolver os bots
			\item Treinar e testar os bots em cenários de testes pré-determinados
			\item Analisar os resultados obtidos
			\item Comparar com implementações existentes de bots para Spelunky
			\item Falar sobre porque não vamos utilizar Behavior Trees mais
		\end{itemize}



	\end{itemize}
}

%----------
\section{\label{section:problem}O Problema}
A prática de estabelecer a complexidade computacional de jogos -- sejam jogos de
carta, jogos de tabuleiro ou jogos digitais -- ajuda a compreender  porque
humanos consideram interessantes os desafios impostos por estes jogos, além de
indicar para pesquisadores da área os desafios propostos vistos de uma
perspectiva de tarefa de otimização.  Dados os desafios presentes em Spelunky
concluiu-se que, computacionalmente falando, trata-se de um problema, no melhor
dos casos, do conjunto \textit{NP-Hard}\cite{SPELUNKYHARD}. O jogo apresenta uma
série de características -- abordadas em detalhe no capítulo \ref{chap:spelunky}
que influenciam fortemente na dificuldade imposta pelo jogo.

Os níveis trazem grandes dificuldades aos jogadores. Em primeiro lugar, o
ambiente em Spelunky é \textbf{contínuo}, \textbf{parcialmente observável},
\textbf{dinâmico}, \textbf{estocástico} e \textbf{sequencial}. Em segundo
lugar, os níveis são gerados proceduralmente, impossibilitanto a memorização do
mapa.  Contudo, o algoritmo utilizado para gerar os níveis garante que existe
pelo menos um caminho transponível do início ao fim -- mesmo que com inimigos e
armadilhas no caminho --, sem que seja necessário o uso de bombas ou cordas
para ajudar na desobstrução do caminho e deslocamento. Sabe-se, também, que o
personagem sempre entra em um nível pela parte superior do mapa, e que a saída
sempre está localizada na parte inferior do mapa. Por fim, cada área em
\textit{Spelunky} possui diferentes características, como tipo de terreno e
monstros diferentes.

Em \textit{Spelunky}, os pontos de vida são o recurso mais importante do
jogador, pois quando esgotados, encerra-se a partida. Existem diversos tipos de
inimigos, armadilhas e perigos naturais cujo único objetivo é impedir o
progresso do jogador.  Somado a isto, depois de 150 segundos em um nível, o
jogador será perseguido incansávelmente por um fantasma que o elimina com apenas
um toque, o que impõe um ''limite`` de tempo que o jogador pode permanecer em um
nível.

O jogo permite que o jogador execute um grande número de ações -- e combinações
de ações -- a cada etapa de atualização do jogo. Algumas delas são influenciadas
por itens equipados ou o estado atual do jogador (no ar, pendurado, etc.), o que
significa que a inteligência artificial desenvolvida deve estar preparada pra
lidar com uma gama gigantesca de possibilidades, pois se não houver cautela, a
execução de uma ação pode gerar resultados inesperados.


%----------
\section{\label{section:objectives}Objetivos}
\todo[inline]{Atualizar objetivos para exploracao de mapa}
Com os desafios e dificuldades apresentados na seção \ref{section:problem}, o
\textbf{objetivo principal} deste trabalho é desenvolver \textit{bots} para o
jogo \textit{Spelunky} que terão como meta se deslocarem do início ao fim de
todos os quatro níveis da área das Minas. Depois da construção dos agentes
inteligentes, coletaremos dados de suas execuções em alguns níveis para realizar
uma análise e comparação aprofundada entre os resultados obtidos por cada
técnica.


%----------
\section{\label{section:techniques}Técnicas de Inteligência Artificial
Utilizadas}
\todo[inline]{Adequar para a saida de Behavior Trees}
Para implementar os \textit{bots} de \textit{Spelunky}, optamos por utilizar as
técnicas \textbf{\textit{NEAT}} e \textbf{\textit{Behavior Trees}}. A
neuroevolução é um modelo de aprendizado de máquina muito utilizado atualmente
para criar agentes jogadores de jogos digitais \cite{DBLP:journals/corr/RisiT14}
e, como vimos no capítulo \ref{chap:related-work}, os resultados obtidos até
agora com este tipo de técnica são muito satisfatórios, muitas vezes superando
as habilidades de jogadores humanos \cite{NeuroEvolutionAtari}. Com isto em
mente, a técnica \textit{NEAT} foi uma escolha natural para este trabalho.

As \textit{Behavior Trees} são muito utilizadas para ajudar na criação de
comportamentos inteligentes para agentes em jogos digitais. Normalmente, esta
técnica não é utilizada para construir agentes jogadores de jogos, mas nada
impede que o formalismo atue neste escopo também. As técnicas de criação de
agentes inteligentes baseadas em aprendizado de máquina são muito poderosas, mas
ao mesmo tempo podem ser vistas como uma ''caixa preta``, pois muitas vezes é
difícil de compreender exatamente o que o agente está pensando e aprendendo.
Optamos por utilizar \textit{Behavior Trees} pois esta técnica permite um ajuste
refinado do comportamento de agentes inteligentes. Assim, esta técnica servirá
de \textbf{base de referência} para medirmos a qualidade dos resultados obtidos
entre uma técnica ''manual`` (\textit{Behavior Trees}) e uma técnica
''automatizada`` (\textit{NEAT}).


%----------
\section{\label{section:project-details}Detalhamento do Projeto}
O primeiro passo para dar início ao desenvolvimento deste projeto é obter uma
cópia do projeto \textit{SpelunkBots}, hospedada no \textit{website} de
versionamento de código
\textit{GitHub}\footnote{https://github.com/GET-TUDA-CHOPPA/SpelunkBots}. O
\textit{framework} conta com o código modificado do \textit{Spelunky} e uma
distribuição do \textit{GameMaker Pro 8.0}, utilizada para compilar e gerar o
arquivo executável do jogo.

Conforme detalhado na seção \ref{section:spelunkbots}, o \textit{SpelunkBots}
disponibiliza duas opções de linguagem de programação para realizar o
desenvolvimento dos \textit{bots}: \textit{GML} ou C++. Portanto, a próxima
etapa do projeto é definir a linguagem de programação que vamos utilizar. Para
este projeto, escolhemos a linguagem de programação \textbf{C++}, tendo em vista
que o desenvolvimento utilizando a linguagem \textit{GML} é extremamente
limitado. Além disso, é possível encontrar na Internet algumas bibliotecas em
C++ que implementam a técnica
\textit{NEAT}\footnote{http://nn.cs.utexas.edu/?neat-c}. O uso de uma biblioteca
salva tempo de desenvolvimento e permite que o foco do trabalho seja somente no
desenvolvimento dos \textit{bots}, e não na arquitetura necessária para tal.

Sabendo que a técnica \textit{NEAT} requer que o \textit{bot} receba treinamento
através de diversas simulações do jogo, optamos pelo uso de um servidor
dedicado, pois este processo pode ser demorado e realizá-lo em uma máquina
doméstica -- que está muito mais sujeita a ser desligada acidentalmente ou
intencionalmente -- seria arriscado. O servidor em questão utiliza um sistema
operacional baseado em \textit{Linux}.  Contudo, \textit{Spelunky} foi
desenvolvido utilizando uma versão muito antiga do \textit{GameMaker} e a
compilação do código externo do \textit{SpelunkBots} ocorre através de um
projeto em \textit{Visual Studio}.  Estas ferramentas só podem ser executadas no
sistema operacional \textit{Windows}. Como nosso servidor é baseado em
\textit{Linux}, é necessário realizar algumas adaptações no processo de
compilação e execução. Assim, utilizaremos os \textit{softwares}
\textit{MinGW}\footnote{http://www.mingw.org} e
\textit{Wine}\footnote{https://winehq.org}, que nos permitirão, respectivamente,
compilar o código C++ e gerar a \textit{DLL} e executar programas da plataforma
\textit{Windows} dentro do sistema operacional \textit{Linux}.

O próximo passo é escolher a biblioteca de inteligência artificial da técnica
\textit{NEAT} e incluí-la no processo de compilação da \textit{DLL},
integrando-a ao projeto \textit{SpelunkBots}. Ao concluir este passo, as
configurações iniciais do projeto estarão finalizadas e daremos início ao
processo de modelagem e desenvolvimento dos \textit{bots}. O diagrama
\ref{fig:project-diagram} ilustra a relação entre os elementos de configuração
do projeto.

\begin{figure}[h]
\centering
\begin{tikzpicture}
    \tikzstyle{every node}=[font=\footnotesize, text centered]
    \node (gmm) at (0, 0)  {Game Maker};
    \node (spl) at (0, -2) {Spelunky};
    \node[draw] (spb) at (0, -4) {SpelunkBots};

    \node[text width=4cm] (conf) at (5, 0)  {Configurações \\(escolha do bot e parâmetros de nível)};
    \node (comp) at (5, -4)  {Compilação (MinGW)};

    \node[draw] (neat) at (9, 0) {Biblioteca NEAT};
    \node[draw] (bt) at (13, 0) {Biblioteca BTs};

    \node (dll) at (11, -2) {Solução DLL};

    \node[draw] (bots) at (11, -4) {Código dos \textit{bots}};

    \node at (0, -6) (wine) {Emulação (WineHQ)};

    \node at (5, -6) (linux) {Servidor Linux};

    \node[draw, inner sep=.25cm, fit={(gmm) (spl) (spb)}] (g2) {};
    \node[draw, fit={(spl) (spb)}] {};

    \node[draw, fit={(dll) (bots)}] (g1) {};

    \draw[->, >=latex] (neat.south) -- (g1.north);
    \draw[->, >=latex] (bt.south) -- (g1.north);

    \draw[->, >=latex] (g1.west) -- (comp.east);
    \draw[->, >=latex] (comp.west) -- (spb.east);

    \draw[->, >=latex, in=0, out=200] (conf.west) to (spb.east);

    \draw[->, >=latex] (g2.south) -- (wine.north);
    \draw[->, >=latex] (wine.east) -- (linux.west);
\end{tikzpicture}
\caption {Diagrama do projeto explicando a relação entre os componentes
necessários para o desenvolvimento dos \textit{bots}.
}
\label{fig:project-diagram}
\end{figure}

\todo[inline]{Remover citações de Behavior Trees}

O \textit{framework} \textit{SpelunkBots} provê uma interface comum para o
desenvolvimento dos \textit{bots} em C++, chamada \textbf{\textit{IBot.h}}. Esta
interface é responsável por expor os métodos e variáveis que os \textit{bots}
utilizam para comunicar-se com o jogo. Portanto, qualquer código de \textit{bot}
desenvolvido deverá partir desta interface. Analisando o arquivo \textit{IBot.h}
é possível perceber que a interface obriga o desenvolvedor a implementar
\textbf{pelo menos} o método \textbf{\textit{Update}}, chamado em todas as
etapas de execução do \textit{bot} para receber informações e enviar comandos ao
jogo. Existem dois outros métodos que podem ser úteis ao desenvolvedor, mas que
não possuem obrigatoriedade de implementação: o \textbf{\textit{Reset}} e o
\textbf{\textit{NewLevel}}. O método \textit{Reset} é chamado no início de todas
as etapas de execução do \textit{bot} para reiniciar suas variáveis de controle.
Este método possui uma implementação padrão que reinicia apenas as variáveis
essenciais (esquerda, direita, pular e atacar). O método \textit{NewLevel} é
chamado toda vez que o \textit{bot} entra em um novo nível, e pode ser usado
para descartar informações do nível anterior sem que seja necessário reiniciar
todas as variáveis do \textit{bot}. Em sua implementação padrão, não executa
nada.

Uma implementação mínima de um \textit{bot} utilizando a interface
\textit{IBot.h} necessitaria, portanto, de dois arquivos: um arquivo
\textit{header}, que conterá as declarações dos métodos e variáveis a serem
utilizadas -- demonstrado no Algoritmo \ref{alg:project-example-bot-header} --,
e um arquivo de implementação -- demonstrado no Algoritmo
\ref{alg:project-example-bot-impl} --, que conterá a implementação das funções
descritas no arquivo \textit{header}.
