\chapter{\label{chap:project}Projeto}


%----------
\section{\label{section:problem}O Problema}
A prática de estabelecer a complexidade computacional de jogos -- sejam jogos de
carta, jogos de tabuleiro ou jogos digitais -- ajuda a compreender  porque
humanos consideram interessantes os desafios impostos por estes jogos, além de
indicar para pesquisadores da área os desafios propostos vistos de uma
perspectiva de tarefa de otimização.  Dados os desafios presentes em Spelunky
concluiu-se que, computacionalmente falando, trata-se de um problema, no melhor
dos casos, do conjunto \textit{NP-Hard}\cite{SPELUNKYHARD}. O jogo apresenta uma
série de características -- abordadas em detalhe no capítulo \ref{chap:spelunky}
que influenciam fortemente na dificuldade imposta pelo jogo.

Os níveis trazem grandes dificuldades aos jogadores. Em primeiro lugar, o
ambiente em Spelunky é \textbf{contínuo}, \textbf{parcialmente observável},
\textbf{dinâmico}, \textbf{estocástico} e \textbf{sequencial}. Em segundo
lugar, os níveis são gerados proceduralmente, impossibilitanto a memorização do
mapa.  Contudo, o algoritmo utilizado para gerar os níveis garante que existe
pelo menos um caminho transponível do início ao fim -- mesmo que com inimigos e
armadilhas no caminho --, sem que seja necessário o uso de bombas ou cordas
para ajudar na desobstrução do caminho e deslocamento. Sabe-se, também, que o
personagem sempre entra em um nível pela parte superior do mapa, e que a saída
sempre está localizada na parte inferior do mapa. Por fim, cada área em
\textit{Spelunky} possui diferentes características, como tipo de terreno e
monstros diferentes.

Em \textit{Spelunky}, os pontos de vida são o recurso mais importante do
jogador, pois quando esgotados, encerra-se a partida. Existem diversos tipos de
inimigos, armadilhas e perigos naturais cujo único objetivo é impedir o
progresso do jogador (detalhados no apêndice \ref{appendix:spelunky-details}).
Somado a isto, depois de 150 segundos em um nível, o jogador será perseguido
incansávelmente por um fantasma que o elimina com apenas um toque, o que impõe
um ''limite`` de tempo que o jogador pode permanecer em um nível.

O jogo permite que o jogador execute um grande número de ações -- e combinações
de ações -- a cada etapa de atualização do jogo. Algumas delas são influenciadas
por itens equipados ou o estado atual do jogador (no ar, pendurado, etc.), o que
significa que a inteligência artificial desenvolvida deve estar preparada pra
lidar com uma gama gigantesca de possibilidades, pois se não houver cautela, a
execução de uma ação pode gerar resultados inesperados.


%----------
\section{\label{section:objectives}Objetivos}
Com os desafios e dificuldades apresentados na seção \ref{section:problem}, o
\textbf{objetivo principal} deste trabalho é desenvolver \textit{bots} para o
jogo \textit{Spelunky} que terão como meta se deslocarem do início ao fim de
todos os quatro níveis da área das Minas. Depois da construção dos agentes
inteligentes, coletaremos dados de suas execuções em alguns níveis para realizar
uma análise e comparação aprofundada entre os resultados obtidos por cada
técnica.


\section{\label{section:project-details}Detalhamento do Projeto}
O primeiro passo para dar início ao desenvolvimento deste projeto é obter uma
cópia do projeto \textit{SpelunkBots}, hospedada no \textit{website} de
versionamento de código
\textit{GitHub}\footnote{https://github.com/GET-TUDA-CHOPPA/SpelunkBots}. O
\textit{framework} conta com o código modificado do \textit{Spelunky} e uma
distribuição do \textit{GameMaker Pro 8.0}, utilizada para compilar e executar o
jogo.

Conforme detalhado na seção \ref{section:spelunkbots}, o \textit{SpelunkBots}
disponibiliza duas opções de linguagem de programação para realizar o
desenvolvimento dos \textit{bots}: \textit{GML} ou C++. Portanto, a próxima
etapa do projeto é definir a linguagem de programação que vamos utilizar. Para
este projeto, escolhemos a linguagem de programação \textbf{C++}, tendo em vista
que o desenvolvimento utilizando a linguagem \textit{GML} é limitado. Além
disso, C++ é uma linguagem amadurecida e possui bibliotecas que implementam
\textit{NEAT}\footnote{http://nn.cs.utexas.edu/?neat-c} e \textit{Behavior
Trees}\footnote{https://github.com/aigamedev/bts}. O uso dessas bibliotecas
salva tempo de desenvolvimento e permite que o foco do trabalho seja somente nos
\textit{bots}, e não na arquitetura necessária.

Sabendo que a técnica \textit{NEAT} requer que o \textit{bot} receba treinamento
através de diversas simulações do jogo, optamos pelo uso de um servidor
dedicado, pois este processo pode ser demorado e executar o processo de
treinamento em uma máquina doméstica -- que está muito mais sujeita a ser
desligada acidentalmente ou intencionalmente -- é arriscado. O servidor em
questão utiliza um sistema operacional baseado em \textit{Linux}.  Contudo,
\textit{Spelunky} foi desenvolvido utilizando uma versão muito antiga do
\textit{GameMaker}, que só pode ser executada no sistema operacional
\textit{Windows}, e o \textit{SpelunkBots} utiliza um projeto em \textit{Visual
Studio} para realizar a compilação do código externo dos \textit{bots}. Como
nosso servidor é baseado em \textit{Linux}, é necessário realizar algumas
adaptações no processo de compilação. Assim, utilizaremos o \textit{software}
\textit{Wine}\footnote{https://winehq.org}, que nos permitirá executar programas
da plataforma \textit{Windows} dentro do sistema operacional \textit{Linux}, e o
\textit{software} \textit{MinGW}\footnote{http://www.mingw.org}, que realizará a
compilação do código C++ e a geração da \textit{DLL}.

O próximo passo é integrar as bibliotecas de inteligência artificial
selecionados com o projeto do \textit{SpelunkBots}, para que estejam incluídas
na solução \textit{DLL}. Ao concluir este passo, as configurações necessárias de
projeto estarão finalizadas, e daremos início ao desenvolvimento dos
\textit{bots}.


\section{Desenvolvimento dos \textit{bots}}
O \textit{framework} \textit{SpelunkBots} provê uma interface comum para o
desenvolvimento dos \textit{bots} em C++, chamada \textbf{\textit{IBot.h}}. Esta
interface é responsável por expor os métodos e variáveis que os \textit{bots}
utilizam para comunicar-se com o jogo. Portanto, qualquer código de \textit{bot}
desenvolvido deverá partir desta interface. Analisando o arquivo \textit{IBot.h}
é possível perceber que a interface obriga o desenvolvedor a implementar
\textbf{pelo menos} o método \textbf{\textit{Update}}, chamado em todas as
etapas de execução do \textit{bot} para receber informações e enviar comandos ao
jogo. Existem dois outros métodos que podem ser úteis ao desenvolvedor, mas que
não possuem obrigatoriedade de implementação:

\begin{itemize}
	\item
		\textbf{\textit{Reset}:} chamada no início de todas as etapas de
		execução do \textit{bot} para reiniciar todas as suas variáveis de
		controle. Possui uma implementação padrão que reinicia apenas as
		variáveis essenciais (esquerda, direita, pular e atacar).

	\item
		\textbf{\textit{NewLevel}:} chamada toda vez que o \textit{bot} entra em
		um novo nível. Pode ser usada para descartar informações do nível
		anterior sem que seja necessário reiniciar todas as variáveis do
		\textit{bot}. Na implementação padrão, não executa nada.
\end{itemize}

Uma implementação mínima de um \textit{bot} utilizando a interface
\textit{IBot.h} necessitaria, portanto, de dois arquivos: um arquivo
\textit{header}, que conterá as declarações dos métodos e variáveis a serem
utilizadas -- ilustrado na Figura \ref{alg:project-example-bot-header} --, e
um arquivo de implementação -- ilustrado na Figura
\ref{alg:project-example-bot-impl} --, que conterá a implementação das funções
descritas no arquivo \textit{header}.

\begin{algorithm}[H]
\lstinputlisting[language=c++]{code/ExampleBot.h}
\caption[Definição de métodos e variáveis de um \textit{bot} de exemplo.]
{\label{alg:project-example-bot-header}Definição de métodos e variáveis de um
\textit{bot} de exemplo.}
\end{algorithm}

\begin{algorithm}[H]
\lstinputlisting[language=c++]{code/ExampleBot.cpp}
\caption[Implementação dos métodos e variáveis de um \textit{bot} de exemplo.]
{\label{alg:project-example-bot-impl}Implementação dos métodos e variáveis de um
\textit{bot} de exemplo.}
\end{algorithm}

É importante ressaltar que, devido ao processo de \textbf{treinamento} do
\textit{bot} que faz uso da técnica \textit{NEAT}, temos a necessidade realizar
operações de \textbf{leitura} e \textbf{escrita} de arquivos, portanto, é
interessante definir um tipo de \textit{bot} que comporte tais operações. Dessa
forma, além do método \textit{Update}, implementaremos os métodos
\textbf{\textit{ReadTrainingData}} e \textbf{\textit{SaveTrainingData}}.
